{"meta":{"title":"dc1y","subtitle":"笃行信道，自强不息","description":"Python, Hexo, Git","author":"czq","url":"https://dc1y.github.io"},"pages":[{"title":"关于我","date":"2018-03-14T03:44:22.000Z","updated":"2018-03-14T03:45:18.098Z","comments":true,"path":"about/index.html","permalink":"https://dc1y.github.io/about/index.html","excerpt":"","text":"本来并无寂静汽笛刺耳如利刃划破水面 刀过水依然无痕声逝寂静却浸透了每个角落"}],"posts":[{"title":"pipenv，人性化的 Python 开发流程","slug":"pipenv-dev-workflow","date":"2018-03-23T10:07:34.000Z","updated":"2018-03-23T10:07:34.000Z","comments":true,"path":"pipenv-dev-workflow/","link":"","permalink":"https://dc1y.github.io/pipenv-dev-workflow/","excerpt":"假设你已经 在系统级上安装了 Python，并受客户 A 委托开发一个网站项目，你为该项目创建了一个文件夹并开始编码，期间还安装了一些库，包括 Django 框架，其版本为 1.8.19。项目投产后反应良好，以至于客户 B 也委托你开发另一个网站，项目 B 同样需要 Django，且其最新版本为 2.3。但你不敢贸然在系统级上安装这个新版本，因为替换掉老版本后，原来的项目 A 可能会因潜在的不兼容问题而出错。这时候你有两个选择：要么继续使用旧版本，要么升级 Django 并确保项目 A 仍能正常运行。 可以肯定的是，这两种做法都无法令你满意。这时候，你就需要 虚拟环境（Virtual Environment） 了。","text":"假设你已经 在系统级上安装了 Python，并受客户 A 委托开发一个网站项目，你为该项目创建了一个文件夹并开始编码，期间还安装了一些库，包括 Django 框架，其版本为 1.8.19。项目投产后反应良好，以至于客户 B 也委托你开发另一个网站，项目 B 同样需要 Django，且其最新版本为 2.3。但你不敢贸然在系统级上安装这个新版本，因为替换掉老版本后，原来的项目 A 可能会因潜在的不兼容问题而出错。这时候你有两个选择：要么继续使用旧版本，要么升级 Django 并确保项目 A 仍能正常运行。 可以肯定的是，这两种做法都无法令你满意。这时候，你就需要 虚拟环境（Virtual Environment） 了。 虚拟环境与包管理如果你在开始项目之前，就分别为项目 A 和项目 B 创建了虚拟环境，那么，你可以自由地在项目 B 中安装 Django 2.3，而丝毫不必担心对项目 A 中现有的 Django 1.8.19 造成影响。 除上述的版本不兼容风险外，不同性质的 Python 项目可能需要安装和使用不同的第三方库，例如网站开发可能会使用 Django、Flask 等，而在进行数据分析时，又可能需要 numpy、pandas 等。如果把所有的第三方库都直接安装到系统级的 Python 环境中，势必会造成不必要的混乱和冗余。此外，若你的项目需要协作，在多个协作者之间重建完全一致的开发环境，也将面临极大的困难。更为严重的是，对于 Linux 等自带 Python 的系统来说，若其任务和操作所依赖的系统级 Python 环境被不慎破坏，甚至可能造成整个系统的崩溃。 解决上述问题的办法是，始终为每一个项目创建一个虚拟环境，并在其中只安装与项目直接相关的各种库及其依赖。每个虚拟环境就是一个独立的文件夹，可确保各项目的依赖彼此隔离，不会相互影响，同时也避免了对系统级的 Python 环境造成污染或破坏。 多年来，Python 社区在虚拟环境及包管理方面开发和积累了大量工具，如 easy_install、pip、virtualenv、virtualenvwrapper、virtualenv-burrito、autoenv、pyenv、pyvenv 等等，甚至 Python 3 还加入了一个名为 venv 的标准库。在这些工具中，最经典且广泛使用的是 pip 和 virtualenv，前者用于管理第三方包，而后者用于管理虚拟环境。 如果你对这些工具及其名称感到眼花缭乱，无所适从，别担心…… 创建于 2017 年 1 月的 pipenv 结束了 Python 虚拟环境及包管理方面的混乱局面。 pipenv 入门目前，pipenv 已成为 Python 官方推荐的包管理工具。它整合了 pip 和 virtualenv 的功能，旨在成为 Python 项目最好的依赖管理器。Pipenv 能够为你的项目自动创建和管理虚拟环境，并在你安装 / 卸载包时，在 Pipfile 中添加 / 移除相关的条目。它甚至能够生成更重要的 Pipfile.lock，从而精确再现开发环境。 与前面提到的其它虚拟环境和包管理工具相比，pipenv 更简明、更人性化。 安装 pipenv作为创建每个项目不可或缺的依赖管理器，Pipenv 几乎是安装 Python 之后的第一个必装工具。不过，为避免 pipenv 及其依赖包破坏系统级上的 Python 环境，最好在用户级上安装 pipenv。 以你的 Windows 帐户登录系统，运行如下命令来确认系统中已安装了 pip，然后使用 --user 参数来在用户级上安装 pipenv： C:\\Users\\username&gt;pip --versionpip 9.0.1 from c:\\program files\\python36\\lib\\site-packages (python 3.6)C:\\Users\\username&gt;pip install --user pipenv 安装完成后，尝试运行如下命令查看 pipenv 的版本号： C:\\Users\\username&gt;pipenv --version'pipenv' 不是内部或外部命令，也不是可运行的程序或批处理文件。 刚刚安装的 pipenv 居然无法使用？原来，执行用户级安装时，pipenv 将被安装到 C:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\Scripts 中。要想能够直接运行 pipenv，必须将这个路径添加到用户的环境变量中。 提示：运行如下命令，可查看用户级的包路径，将最后的 site-packages 替换为 Scripps，就是用户级可执行文件（包括 pipenv）的安装位置： C:\\Users\\username&gt;py -m site --user-siteC:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\site-packages 进入 “控制面板 | 用户帐户 | 用户帐户”，单击左侧的 “更改我的环境变量”（如下图），打开当前用户的“环境变量” 对话框，在上方的用户变量列表中选择 Path 并单击 “编辑…”，添加 C:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\Scripts 后，依次点击各对话框的“确定” 来确认修改： 提示：在开始菜单中搜索 “环境变量”，并单击找到的 “编辑帐户的环境变量”，可以快速打开当前用户的 “环境变量” 对话框。 重新启动命令提示符，再次查看 pipenv 的版本，可发现刚刚设置的用户环境变量已经生效： C:\\Users\\username&gt;pipenv --versionpipenv, version 11.8.3 pipenv 的基本操作使用传统的 pip 和 virtualenv，项目的虚拟环境及包管理通常涉及若干步骤：创建虚拟环境、激活虚拟环境、安装项目所需的包、禁用虚拟环境等等。并且，在项目开发过程中，还需要时不时手工维护 requirements.txt。整个过程相当繁琐，除非始终保持警惕和耐心，否则非常容易出错。 相比之下，pipenv 的虚拟环境及包管理则非常简单，大大缓解了虚拟环境及包管理的脑力消耗。 初始化项目创建并进入名为 myproj 的项目文件夹，运行 pipenv install 即可初始化项目环境（如下图）： 提示 ：在 Windows 10 中，要在指定路径快速打开 “命令提示符”，可在资源管理器中打开该路径，Shift + 右击任意空白位置，并从弹出的菜单中选择 “在此处打开 PowerShell 窗口”，然后在 PowerShell 中运行 cmd 命令。 初始化项目时，pipenv 在当前用户目录的 .virtualenvs 中创建了一个虚拟环境（上图①），并在项目文件夹中生成 Pipfile 文件和 Pipfile.lock 文件（上图②），然后锁定项目依赖并更新 Pipfile.lock，再按该文件的内容安装依赖——当然，目前项目的依赖数量为 0。 从命令输出中可以看到，虚拟环境中包含系统级 python.exe 的副本，并且也安装了 setuptools、pip、wheel 等工具，构成了一个完整的、独立于系统级的 Python 运行环境。运行如下命令，可查看项目虚拟环境的路径，并确认当前采用的 python.exe 来自于这个虚拟环境： D:\\temp\\myproj&gt;pipenv --venvC:\\Users\\dc1y\\.virtualenvs\\myproj-rd7BNkmTD:\\temp\\myproj&gt;pipenv --pyC:\\Users\\dc1y\\.virtualenvs\\myproj-rd7BNkmT\\Scripts\\python.exe Pipfile 及相应的 Pipfile.lock 文件用于跟踪管理项目的依赖信息，可取代并且优于传统的 requirements.txt。Pipfile 定义了项目的具体要求，包括从何处获取依赖包，对直接依赖包进行分组等内容。项目环境的细节则存储在 Pipfile.lock 中，包括所有的第三方包及其递归依赖包的确定版本号及其它信息，可用于精确再现项目环境。Pipfile.lock 通过 pipenv lock 命令自动生成，不必也不可手工创建和修改。 由于项目当前没有任何依赖，因此 Pipfile 和 Pipfile.lock 文件中只有一些骨架代码。 提示：Pipfile 和 Pipfile.lock 均应纳入到项目的版本管理中。 安装项目依赖包安装依赖包的命令与初始化项目的命令是一样的，只不过加上了要安装的包而已。实际上，你可以跳过初始化项目阶段，直接采用如下命令来在一个步骤中初始化项目、同时安装指定的包： D:\\temp\\myproj&gt;pipenv install requestsInstalling requests…...Adding requests to Pipfile's [packages]…Pipfile.lock (48ca4e) out of date, updating to (18fa8f)…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (18fa8f)!Installing dependencies from Pipfile.lock (18fa8f)… ================================ 8/8 - 00:00:03To activate this project's virtualenv, run the following: $ pipenv shell 无需专门激活虚拟环境，只需一个命令即可安装指定的包，同时更新 Pipfile 和 Pipfile.lock 文件。默认时，pipenv 将安装指定包的当前版本，若需指定具体版本，可包名后面加上版本号，例如：pipenv install requests==&#39;2.18.4&#39;。 除项目产品所需的包外，项目开发环境中通常还会用到其它包，如单元测试的 pytest、nose 等，但产品环境并不需要它们。为区分这种类型的包，可在运行安装命令时加入 --dev 选项： D:\\temp\\myproj&gt;pipenv install --dev pytestInstalling pytest…Collecting pytest Downloading pytest-3.5.0-py2.py3-none-any.whl (194kB)...Successfully installed attrs-17.4.0 colorama-0.3.9 more-itertools-4.1.0 pluggy-0.6.0 py-1.5.3 pytest-3.5.0Adding pytest to Pipfile's [dev-packages]…Pipfile.lock (85daf0) out of date, updating to (48ca4e)…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (48ca4e)!Installing dependencies from Pipfile.lock (48ca4e)… ================================ 10/10 - 00:00:04To activate this project's virtualenv, run the following: $ pipenv shell 从命令输出中可以看到，pytest 及其依赖已被安装到项目环境中。同时，在 Pipfile 文件的 [dev-packages] 部分添加了 pytest，并更新了 Pipfile.lock 文件的 &quot;develop&quot; 部分。 使用已安装的包现在，编写一个简单的 main.py，在其中导入并使用刚刚安装的 requests： import requestsresponse = requests.get('https://httpbin.org/ip')print('Your IP is &#123;0&#125;'.format(response.json()['origin'])) 然后，使用 pipenv run 命令来运行这个脚本，该命令将自动激活虚拟环境： D:\\temp\\myproj&gt;pipenv run python main.pyYour IP is 8.8.8.8 你也可以先激活虚拟环境，再直接使用 python 来运行脚本（exit 可退出虚拟环境）： D:\\temp\\myproj&gt;pipenv shellLaunching subshell in virtual environment. Type 'exit' to return.Microsoft Windows [版本 10.0.16299.309](c) 2017 Microsoft Corporation。保留所有权利。D:\\temp\\myproj&gt;python main.pyYour IP is 8.8.8.8D:\\temp\\myproj&gt;exitD:\\temp\\myproj&gt; pipenv 的其它操作如果希望把虚拟环境放在项目文件夹内，可在当前用户的 “环境变量” 对话框中，增加一个名为 PIPENV_VENV_IN_PROJECT 的用户变量，并将其值设置为 1（如下图）。 重启 “命令提示符” 后，运行如下命令，先移除用户目录中的现有虚拟环境，再在项目的. venv 目录中重建项目虚拟环境： D:\\temp\\myproj&gt; pipenv --rmRemoving virtualenv (C:\\Users\\username\\.virtualenvs\\myproj-rd7BNkmT)…D:\\temp\\myproj&gt;pipenv installCreating a virtualenv for this project…...Virtualenv location: D:\\temp\\myproj\\.venvInstalling dependencies from Pipfile.lock (7b8df8)… ================================ 5/5 - 00:00:04To activate this project's virtualenv, run the following: $ pipenv shell 提示 ：如果需要重建项目开发环境，则加上 --dev 选项，即 pipenv install --dev。 此外，卸载不再需要的包可使用 pipenv uninstall 命令，更新包可使用 pipenv update 命令，显示依赖图可使用 pipenv graph 命令，等等。更多的命令和选项，请参阅 pipenv 官方文档。 尾声pipenv 确实简化了 Python 项目的虚拟环境和包管理。掌握了 pipenv，或许可在今后的项目节省你的时间，并减轻你的痛苦。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"pipenv","slug":"pipenv","permalink":"https://dc1y.github.io/tags/pipenv/"}]},{"title":"在 Windows 上安装系统级的 Python","slug":"python-global-installation","date":"2018-03-22T08:09:11.000Z","updated":"2018-03-22T08:09:11.000Z","comments":true,"path":"python-global-installation/","link":"","permalink":"https://dc1y.github.io/python-global-installation/","excerpt":"提示：Python 核心团队已计划在 2020 年 1 月 1 日正式停止支持 Python 2，除非确实需要，否则应尽早安装并迁移到 Python 3。 在 Windows 中，Python 的安装似乎非常简单，按大多数教程的说法，只需从 Python.org 下载适合你的操作系统的安装程序，然后运行这个安装程序，在安装界面上启用 Add Python 3.6 to PATH，再单击 Install Now，即可完成安装： 不过，这种 “简单” 的安装方式，实质上是在用户级别上安装 Python，最终的安装位置位于当前用户目录下（如 C:\\Users\\&lt;username>\\AppData\\Local\\Programs\\Python\\Python36\\），其结果是只有当前用户能够使用 Python。一旦你以其它用户登录 Windows，运行 python 命令将出现如下错误提示： &apos;python&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。","text":"提示：Python 核心团队已计划在 2020 年 1 月 1 日正式停止支持 Python 2，除非确实需要，否则应尽早安装并迁移到 Python 3。 在 Windows 中，Python 的安装似乎非常简单，按大多数教程的说法，只需从 Python.org 下载适合你的操作系统的安装程序，然后运行这个安装程序，在安装界面上启用 Add Python 3.6 to PATH，再单击 Install Now，即可完成安装： 不过，这种 “简单” 的安装方式，实质上是在用户级别上安装 Python，最终的安装位置位于当前用户目录下（如 C:\\Users\\&lt;username>\\AppData\\Local\\Programs\\Python\\Python36\\），其结果是只有当前用户能够使用 Python。一旦你以其它用户登录 Windows，运行 python 命令将出现如下错误提示： &apos;python&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。 要在系统级上安装可供所有 Windows 帐户使用的 Python，必须采用自定义的安装方式。下面是在 Windows 10 64-bit 平台上安装系统级 Python 的步骤： 以管理员帐户登录 Windows，运行 Python 安装程序，并选择 Customize installation： 保持 Optional Feature 的默认选择，并单击 Next： 在 Advanced Options 中，启用 Install for all users 及 Add Python to environment variables，然后单击 Install 开始安装： 安装完成后，在管理员和非管理员用户中，运行 “命令提示符” ，并输入如下命令查看刚刚安装的 Python 的版本号。一切顺利的话，你就可以在多个 Windows 用户中使用 Python 了： C:\\Users\\&lt;username&gt;python --versionPython 3.6.4 提示：如果你打算执行全新的安装，则应在卸载 Python 后，再删除原来的安装目录及其中可能遗留的包。 安装好 Python 后，在开始任何项目之前，你还必须全面了解 Python 的虚拟环境和包管理的概念，并掌握相关工具的使用，详见《pipenv，人性化的 Python 开发流程》》。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"}]},{"title":"VS Code，打造沉浸式 Hexo 写作环境","slug":"blogging-in-hexo-with-vscode","date":"2018-03-13T13:58:54.000Z","updated":"2018-03-16T08:05:11.364Z","comments":true,"path":"blogging-in-hexo-with-vscode/","link":"","permalink":"https://dc1y.github.io/blogging-in-hexo-with-vscode/","excerpt":"在 《Hexo 你的专属博客》 一文中，你了解到了如何搭建 Hexo 博客站点并部署到远程仓库，实现了博文源码及站点配置的备份，并且还探讨了如何在多个设备上同步博客站点。 本文主要包括两方面的内容，首先是了解 Hexo 中与写作的相关事项和概念，其次是介绍如何利用 Visual Studio Code 来打造一个专注无干扰的 Markdown 写作环境。读完本文，你就可以做到心无挂碍、高效流畅地撰写你的博文了。","text":"在 《Hexo 你的专属博客》 一文中，你了解到了如何搭建 Hexo 博客站点并部署到远程仓库，实现了博文源码及站点配置的备份，并且还探讨了如何在多个设备上同步博客站点。 本文主要包括两方面的内容，首先是了解 Hexo 中与写作的相关事项和概念，其次是介绍如何利用 Visual Studio Code 来打造一个专注无干扰的 Markdown 写作环境。读完本文，你就可以做到心无挂碍、高效流畅地撰写你的博文了。 Hexo 的常规写作方式现在，先来了解一下 Hexo 的常规写作方式，顺便了解 Hexo 的一些非常重要的概念。 按 Hexo 官方文档 的说明，创建新博文的命令如下： $ hexo new [layout] &lt;title&gt; 运行这个命令，即可为新博文创建一个 Markdown（.md）文件。并且，若此时启动 Hexo 本地服务器，也可看到博文已经添加到站点中了。这个命令有两个选项： layout：为新博文指定布局，未指定时默认采用 post 布局。其余两个布局选项分别是 draft 和 page。 title：指定新博文的文件名，同时也是新博文在页面上最初显示的标题。若指定的标题中包含空格，则必须包围在一对半角双引号中（建议总是加上双引号，省心）。标题也可以是中文，不过英文的文件名兼容性更好。此外，Hexo 会自动将文件名中的下划线（_）自动更改为连字符（-）。 关于 Hexo 的布局所谓的 布局（layout），就是博文最终呈现出来的外观排版。如下图所示，你在每篇博文中输入的内容，将被 “嵌入” 到最终页面的 “正文” 位置。而正文之外的其它内容，如页眉、页脚及边栏等，则由 Hexo 根据你指定的布局及站点主题自动生成。 某种布局最终呈现出来的版面外观效果，由当前主题的 layout 文件夹中的同名 .ejs 文件定义。在生成最终的静态页面时，Hexo 会自动把每一篇博文 “嵌入” 到相应的 .ejs 布局中——_posts 中的博文嵌入 post.ejs 布局，_drafts 中的博文嵌入 draft.ejs 布局，而 page 博文则采用了 page.ejs 布局。 当然，最终的版面效果取决于你使用的主题。不同的主题定义了不同内容的 .ejs 文件集，而你的博文，总是 “一如既往” 地嵌入到相应的布局中的某个位置。这，也是你能够随心所欲地切换站点主题的原因。 作为测试，运行 hexo n &quot;test&quot; 命令创建一篇博文，观察 Hexo 自动在 source\\_post 文件夹中生成名为 test.md 的文件。启动 Hexo 服务器并在浏览器中查看本地站点和博文，观察并体会博文与其它布局元素之间的关系。 关于 Hexo 的模板在你的编辑器中打开刚刚生成的 test.md 文件，可发现文件中已包含如下内容： ---title: testdate: 2018-03-07 14:45:03tags:--- 两个 --- 及它们之间的内容，就是所谓的 front matter，用于保存关于博文的元数据。除博文标题及创建时间外，还可以在这里指定博文的标签、类别、关键字等等。完整的 front matter 参数及用途，请参阅 Hexo 文档。 这些 front matter 源自于 Hexo 的模板。在创建博文时，Hexo 将根据你指定的 layout，自动对博文应用 scaffolds 文件夹中的相应模板。由于刚才创建博文时采用了默认的 post 布局，因此 Hexo 将自动套用 scaffolds\\post.md 模板来生成 test.md。 在编辑器中打开 scaffolds\\post.md 模板，可发现其中包含与 test.md 中对应的 front matter。当然，双花括号之间的 title 和 date，已被自动替换为新博文的标题和创建时间： ---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags:--- Hexo 的默认模板比较简陋，你可以根据实际需要在模板中增加常用的元数据，如更新时间、类别及关键字等，以便在今后创建博文时，自动生成更完整的 front matter。例如： ---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;updated: &#123;&#123;date&#125;&#125;tags:categories:keywords:--- 回到 test.md，把 front matter 中双花括号中的 title 修改为 博文测试，并在后一个 --- 之后随便输入一些内容作为博文的正文。告一段落后，在浏览器中刷新博客站点，可发现新博文的标题和内容也随着更新了。可见，Hexo 服务器能够自动监视博文内容的改变，并且无需重启。 提示：博文的页面标题不必总是与文件名保持一致。随着你撰写越来越多的博文，你会发现现实中往往如此。即使是 Hexo 默认提供的 “Hello World” 博文，其文件名也是不一致的 “hello-world.md”。 关于标签和类别当你的博文数量越来越多的时候，你或你的读者要怎样才能快速找到想要阅读的博文呢？Hexo 通过标签和类别提供了两种归类和检索博文的方式。 标签通常是从博文内容提炼的一个或多个关键词。你可以在 front matter 的 tags: 节点中，按如下方式为每一篇博文指定一个或多个标签： # 若只有单个标签，则在同一行中指定（注意冒号后有一个空格）tags: hexo# 若需要多个标签，则以多行方式指定tags:- hexo- git 指定标签后，刷新站点页面，即可在侧边栏看到 “标签” 栏目。单击该栏目中的某个标签，将列出所有含有该标签的博文的链接；单击任一链接，即可打开并阅读相应的博文。 除标签外，你还可以从另一维度给你的博文分类。在 front matter 中增加 categories: 节点，并指定博文所属的一个或多个类别。同样，刷新站点可马上看到 “分类” 栏目： # 若只有单个类别，则在同一行中指定（注意冒号后有一个空格）categories:# 若需要多个类别，则以多行方式指定categories:- 实用工具- Hexo 需要注意的是，与多个标签并无主次之分不同，多个类别间具有层级关系。首先列出的类别为一级类别，后续列出的类别依次为其前面类别之下的子类别。以上面的多类别设置为例，页面上将把 “Hexo” 类别缩进显示在 “实用工具” 类别之下，表示 “Hexo” 是 “实用工具” 中的一个子类别。 提示：不同的主题，可能采用不同的方式来呈现类别，例如，Hueman 主题将以菜单的形式来显示类别。 关于 draft 和 page前面提到，创建新博文时，还可以选择 draft 和 page 布局。难道，除了写博文之外，你还需要写别的什么吗？ 是的。你还可以使用 draft 布局来创建草稿或不想公开发表的博文，而 page 布局则可为你的博客站点增加功能性的页面。 实际上，新建博文命令的 layout 参数也决定了新生成的博文的存放位置。采用 post 布局的博文文件将自动存放到 source\\_posts 文件夹中，draft 博文存入 source\\_drafts 文件夹，而 page 页面则直接存放在 source 文件夹中。 假设你突然产生了一个想法，但还不够成熟，也暂时没时间将其写成正式的博文，那么，你可以用 hexo n draft &quot;my-idea&quot; 来创建一篇草稿，并在其中快速且粗略地记下这个想法。当然，你也可以利用这个草稿来收集相关的资料。 提示：如果你跟我一样，希望每次新建博文都从草稿开始，则可在站点配置文件中，把 default_layout 设置为 draft。这样运行 hexo n &quot;&lt;filename&gt;&quot; 命令就将直接创建草稿，而不是正式的博文。 默认时 Hexo 不会在站点中显示草稿，也不会在远程仓库中公开发布（放心，只是没有公开发布到 master 分支而已，草稿的源码依然会备份到 src 分支）。在逐步润饰完善草稿的过程中，如果你想要预览草稿的效果，只需在启动 Hexo 服务器时加上 --drafts 参数，如 hexo s --drafts，即可让本地站点同时显示出所有草稿和博文。 最后，当你打算把草稿发布为正式的博文时，运行 hexo publish &quot;&lt;filename&gt;&quot; 命令来把把指定的草稿从 source\\_drafts 中转移到 source\\_posts 中，并自动填写发布时间。从这时候起，这篇草稿就会像普通的博文一样公开发布了。 警告：不要把站点配置中的 render_drafts 设置为 true，这将导致所有草稿也被公开发布，除非你想公开尚未完成的或隐私的博文。 至于使用 page 布局来生成功能性页面方面，给站点添加 “关于我” 的页面，就是一个很好的例子。运行如下命令来创建自我介绍页面： hexo n page \"about\" Hexo 自动在 source 文件夹中生成 about\\index.md 文件。在编辑器中打开该文件，并输入你的简介，完成后保存。然后，打开主题配置文件（例如themes\\landscape\\_config.yml），并在 menu 中添加 About: /about 菜单。如下： menu: Home: / Archives: /archives About: /about 现在，你已经掌握了 Hexo 中与博文相关的基本概念了。遵循简洁轻便低入侵性的 Markdown 语法，你可以开始 “专注无干扰” 地撰写你的博文了。 提示：Markdown 是一种轻量级的纯文本标记语言，只需输入少量标记，即可生成格式优美的印刷级排版。如果你还不了解 Markdown，可参考 Markdown 快速入门。 用 Visual Studio Code 撰写博文专注无干扰？没错，Markdown 语法本身的确简洁流畅，但在创建、编辑和预览博文的过程中，既要运行 Git Bash 并输入命令，又要在文本编辑器中一层层寻找并打开文件，还是会时不时打断写作思路的。 说得好！你已经想到了，但你还不知道，你需要使用 Visual Studio Code。 Visual Studio Code（后称 VS Code）是微软出品的一个跨平台、轻量级且功能强大的代码编辑器，原生支持 JavaScript、TypeScript 及 Node.js，并且可通过扩展（即插件）来支持 C++、C#、Java 及 Python 等几乎所有语言，当然也包括你在 Hexo 中撰写博文所使用的 Markdown 语言。VS Code 一经推出即好评如潮，是文本或代码编辑器的不二之选。 提示：访问 VS Code 官方站点 来获取更多相关信息。 近年来，各种各样的 Markdown 编辑器层出不穷，在线的离线的都有。在我们的情形中，VS Code 之所以能够脱颖而出，是因为 VS Code 在界面中集成了一个终端，默认配置为使用 Windows PowerShell。在这个集成终端中，你可以输入并执行任何命令，无论是你已渐渐熟悉的 hexo 命令、还是 git 命令，以及 Node.js 的 npm 命令，都可以信手拈来。 提示：如果你希望使用其它终端（比如 Git Bash），则可在 VS Code 中按下 F1 键打开 “命令面板”，输入 Select Default Shell 后回车，然后从清单中选择 Git Bash 即可。 有了这个多才多艺的 VS Code，你就可以进入真正 “专注无干扰” 地撰写博文的禅境了。 进入写作禅境启动 VS Code，选择 文件 | 打开文件夹 打开你的博客站点文件夹。 按下 Ctrl+` 激活 VS Code 下方的 “终端” 面板，输入 hexo n &quot;myblog&quot; 并回车。片刻之后，source\\_posts 中就生成了 myblog.md 文件。 提示：你应该已经了解到，几乎所有的 Hexo 命令都有对应的简化版本，例如 hexo n 相当于 hexo new、hexo s 相当于 hexo server 等等。关于完整的 Hexo 命令清单，请参阅 Hexo 文档。 按下 Ctrl+P 激活 VS Code 的 “快速打开” 面板，并输入刚刚创建的文件名 myblog，从弹出的清单中选择 “myblog.md source\\_posts” 并回车，VS Code 随即在编辑器窗口中打开这个文件。 接下来，想必你已经知道了，不外乎就是像平常一样修改 front matter，遵循 Markdown 规则来撰写你的博文了。 如果想预览博文，可按下 Ctrl+K, V 打开 VS Code 自带的 Markdown 预览窗口。当然了，你在这里看到的，只是博文本身内容的预览。 如果想预览整体效果，可激活终端并执行 hexo s -o，启动 Hexo 本地服务器并自动在默认浏览器中打开博客站点（这是 -o 选项的效果）。 提示：启动 Hexo 服务器后，当前的终端就被占用了。如果需要执行其它命令，同时又不想按下 Ctrl+C 来关闭 Hexo 服务器，则可按下 Ctrl+Shift+` 来打开一个新的集成终端（终端面板右上角的下拉列表，可用来在不同的终端间切换）。 你可能已经注意到了，到现在为止，你的手还没有离开过键盘！ 在 VS Code 中，一切都在你的指尖。大多数情况下，你都不用中止输入，不必腾出手来抓住鼠标到处寻找和点击——这不但影响了你的效率，也干扰了你的思路。 如果你足够细心的话，你会发现 VS Code 侧边栏的 “源代码管理” 图标上，叠加了一个带有数字的圆点。这意味着 VS Code 内置的 Git 检测到了当前站点与远程仓库之间存在未同步的内容。不过，远程仓库的管理和站点的部署，仍然必须使用 Hexo 的 deploy 命令。因为，在部署到远程仓库之前，Hexo 还执行了大量的操作，包括博文内容与布局的合成，以及生成最终的静态 HTML 文件等。 当你完成了新博文的编辑，或者是修改了站点的配置之后，就可以执行一次清理，并通过部署来发表博文和备份站点。依然是激活集成终端，然后输入并执行如下命令——你还是不用离开键盘： $ hexo cleanINFO Deleted database....$ hexo d -gINFO Start processing... 至此，你已渐渐进入撰写博文的禅境。一切纷扰离你而去，万籁俱寂之中，你正全神贯注、心无旁骛地让你的思想和见解，静静地经由你的指尖流淌出来…… 继续扫清障碍你已经能够专注无干扰地撰写博文了。不过，前行的路上，多少还有一些小障碍需要克服。在 Markdown 方面，VS Code 扩展市场中存在若干插件，适当的利用可进一步提高你的写作效率和质量。 markdownlintmarkdownlint 是一个 Markdown 语法检查器。博文中不符合 Markdown 规范的内容将被标上波浪线，并提供相应的改进提示。这个扩展可确保你的博文具有更高的兼容性（可由 Hexo 之外的其它 Markdown 解析器顺利读取），同时也可帮助你形成规范的语法习惯。 提示：按下 Ctrl+Shift+X 在侧边栏打开 “扩展” 面板，输入扩展名称即可自动执行搜索，找到所需扩展后，单击其右下角的 “安装” 按钮并耐心等待。安装完成后出现 “重新加载” 按钮，单击即可让新安装的扩展马上生效。 Markdown Shortcuts顾名思义，这个扩展为 VS Code 提供了一组插入 Markdown 标记的快捷键。尽管 Markdown 与 HTML 相比已非常简洁，但插入链接（[a hyperlink](www.example.org)）或图像（![alt text](image_url.png)）的标记仍然颇为复杂，尤其是在使用中文输入法时，时常会因忘记切换全角半角标点符号而反复犯错，极大地影响了输入的流畅性。安装此扩展后，只需： 按下 Ctrl+L，然后，若已选定了链接文本，则直接粘贴事先复制好的目标URL；否则填入链接文本后再粘贴URL。 要插入 Markdown 图像标记，可使用 Ctrl+Shift+L 快捷键。更多信息，靖参阅该扩展主页上的 “详细信息”。 提示：如果你使用 Chrome 浏览器的话，也可考虑使用名为 copy-as-markdown 的浏览器扩展，来直接从浏览器上获取 Markdown 格式的链接。 Hexo 在图像路径解析方面似乎存在问题，在 VS Code 预览中正常显示的图像，往往无法显示在远程发布后的页面上，反之亦然。一种比较简明的解决方法是：把所有图片放入 source\\imgs 文件夹中，在站点配置文件中设置 permalink: :title/，同时在博文中以 ../imgs/example.png 的形式引用图像。这样，预览和发布的博文就都可以正确显示图像了。 VS Code-pangu这是一个非常简单的插件，用于在中文和英文字符之间插入一个空格，让最终的排版结果更美观。安装 VS Code-pangu 后，只需按下 F1、输入 Why not add a space... 并回车，即可给全文或选定的内容自动插入空格。 Hexo 也有一个可以自动插入空格的插件 hexo-filter-auto-spacing，安装该插件后再在站点配置文件中设置 auto_spacing: true 即可使用。 不过，并非所有的中英文之间都适合插入空格，例如加粗的中文 **提示** ，自动插入空格后，最终的输出会变成 ** 提示 **，失去加粗效果。因此，使用 VS Code-pangu 的可控性更好，可以在编辑器中更正不适当插入的空格。 注意：如果一次性在全文中插入了空格，则应在发布前进行检查，并删除掉意外插入的不必要的空格。 Markdown Preview Enhanced改善了 VS Code 的 Markdown 预览，可显示博文目录方便导航，并支持输出 HTML、PDF、eBook 等格式。 Hexo tag snippets除标准的 Markdown 标记外，博文中也可以使用 Hexo 的 自定义标记。例如，下面的标记，可用于在博文中插入站内博文链接： &#123;% post_link slug [title] %&#125; 不过，要注意这些标签只有在 Hexo 才能正确解析，其它 Markdown 解析器很可能无法解析这些标记（实际上，VS Code 的预览就无法解析这些标记），因此应尽量慎用。 如果确实需要使用 Hexo 标记，你可以安装名为 Hexo tag snippets 的 VS Code 扩展。该扩展把 Hexo 标记定义为代码片段，只需简短的输入几个字符，就可快速输入这些标记。例如，输入 hcb 并选择 “Code Block - General (Hexo tag snippets)”，可快速插入如下的代码块标记： &#123;% codeblock title lang:language %&#125;&#123;% endcodeblock %&#125; 默认时，VS Code 并未启用 Markdown 的智能感知。要在撰写博文时使用代码片段的功能，需要添加如下用户配置： \"[markdown]\": &#123; \"editor.wordWrap\": \"on\", \"editor.quickSuggestions\": true&#125;, 提示：对于 Markdown 来说，智能感知有利有弊。若感觉你的写作受到影响，并且你的博文内容只需要少量 Hexo 标记，则不要启用该功能。 此外，你还可以在 VS Code 中定义你自己的代码片段。选择 文件 | 首选项 | 用户代码片段，打开 markdown.json 并输入如下内容，就可以使用 hxpl 和 hxrm 来快速插入站内博文链接和博文摘要的代码片段了： \"hexo post link\": &#123; \"prefix\": \"hxpl\", \"body\": [ \"&#123;% post_link $&#123;1:filename&#125; $&#123;2:title&#125; %&#125;$0\" ], \"description\": \"Link to blog article\"&#125;,\"hexo readmore\": &#123; \"prefix\": \"hxrm\", \"body\": [\"&lt;!--more--&gt;\", \"$0\"], \"description\": \"read more\"&#125; 以上内容说明，除集成终端外，VS Code 强大的扩展能力，是又一个让它完胜其它 Markdown 编辑器的特性。扩展的可能性是无穷的，并且会随着时间的推移和社区的反馈而越来越好用。甚至，有必要的话，你还可以编写你自己的扩展。 尾声经过一番跋涉，你终于达到了撰写博文的新境界。放松下来后，你可能会觉得 Hexo 的默认主题有些乏味。 如果想要以全新的面貌来呈现你的博文，可访问 Hexo 官方网站的主题页面，找到你喜欢的主题，并按其说明把主题下载（通常是使用 git clone 命令）到 themes 文件夹中；然后在站点配置文件中，把 theme: landscape 中的 landscape 修改为新主题的名称。 大多数主题在其自身文件夹中提供了 _config.yml 配置文件。利用这个主题配置文件，可以对主题的各种细节进行设置和调整。 本篇到此为止，享受你的写作吧！","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://dc1y.github.io/categories/实用工具/"},{"name":"Hexo","slug":"实用工具/Hexo","permalink":"https://dc1y.github.io/categories/实用工具/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dc1y.github.io/tags/Hexo/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://dc1y.github.io/tags/Visual-Studio-Code/"},{"name":"Markdown","slug":"Markdown","permalink":"https://dc1y.github.io/tags/Markdown/"}]},{"title":"Hexo 你的专属博客","slug":"hexo-your-blog","date":"2018-03-11T09:32:00.000Z","updated":"2018-03-17T05:41:42.838Z","comments":true,"path":"hexo-your-blog/","link":"","permalink":"https://dc1y.github.io/hexo-your-blog/","excerpt":"你有没有，经历过个人电脑的硬件故障，所有辛苦撰写或整理的资料烟消云散，捧着一块变成砖头的硬盘欲哭无泪？ 你想不想，把你撰写或整理的资料上传到网上，以便可以随时随地进行访问和阅读，并分享给与你有或类似需要的人？ 如果答案是肯定的，那么，你应该搭建一个专属的博客站点。 本文基于 Windows 10 x64 操作系统，主要描述如何利用 Hexo 及 GitHub 和 / 或码云来搭建你的专属博客站点。本文涉及的工具软件及网络服务大致如下：","text":"你有没有，经历过个人电脑的硬件故障，所有辛苦撰写或整理的资料烟消云散，捧着一块变成砖头的硬盘欲哭无泪？ 你想不想，把你撰写或整理的资料上传到网上，以便可以随时随地进行访问和阅读，并分享给与你有或类似需要的人？ 如果答案是肯定的，那么，你应该搭建一个专属的博客站点。 本文基于 Windows 10 x64 操作系统，主要描述如何利用 Hexo 及 GitHub 和 / 或码云来搭建你的专属博客站点。本文涉及的工具软件及网络服务大致如下： Hexo：是一个快速、简洁且高效的静态博客框架，可使用 Markdown 格式来编写博文，能够自动生成静态 html 文件，并一键部署到远程仓库。Hexo 的运行需要 Node.js。 Node.js：是一个基于 Chrome V8 引擎构建的 JavaScript 运行时，让 JavaScript 可以在非浏览器环境下运行。若将 Node.js 视为一个解释器，则 Hexo 就是一个通过这个解释器而运行的应用。 Git：是一个广泛应用的、先进的分布式版本管理工具软件。 GitHub.com：是全球最大的代码托管网站，也是本文博客站点的远程部署位置之一。使用 Git 可以与 GitHub 进行交互，并实现代码仓库的版本管理。 Gitee.com：中文名为码云，是类似于 GitHub 的国内代码托管仓库，可免费建立私有项目，同时也提供了项目管理等更多的功能。 为什么选择 Hexo：目前开源社区存在大量的博客框架，如 WordPress、Jekyll 等，规模不一架构迥异，根据各人知识背景及需求，可能会有不同的偏好和选择。本文选用 Hexo，主要基于轻便、免费及无需后台服务器等方面的考虑。 本文的主要内容有：安装相关软件、建立本地博客站点、部署到远程仓库，以及在多个设备间实现博客站点的同步等。 安装相关软件Hexo 的安装和运行，以及后续博客站点的远程部署和管理，要求在系统中安装好 Git 和 Node.js。 安装 Git 和 Node.js从 Git 和 Node.js 官方网站下载适用本机平台的安装程序，目前 Git 的版本为 2.16.2、Node.js 的版本为 8.9.4。 双击运行刚下载的安装程序，并按屏幕提示完成安装。安装时采用默认选项即可，但要特别注意启用了与环境变量（PATH）相关的选项。 安装完成后，从开始菜单中选择 “Git | Git Bash”（也可使用 Windows 的命令提示符，但推荐使用 GitHub Bash），输入如下命令，若正确显示 Git 和 Node.js 版本，则表明安装成功： $ git versiongit version 2.16.2.windows.1$ node -vv8.9.4 安装 Hexo继续在 Git Bash 中输入如下命令，并耐心等待相关依赖包的下载，当屏幕上显示如下提示且返回提示符 $ 时，即表示 Hexo 已安装完成： $ npm install -g hexo-cli...+ hexo-cli@1.1.0added 103 packages in 25.033s 提示：npm 是随同 Node.js 一起安装的 JavaScript 的包管理器，用于从 NPM 服务器上下载第三方包（例如本文主角 Hexo 等）到本地使用。若国外 NPM 服务器连接不便或速度很慢，可通过如下命令来启用国内的淘宝 NPM 镜像：&gt; $ npm config set registry https://registry.npm.taobao.org&gt; 随后，使用下面的命令来查看刚刚安装的 Hexo 的版本： $ hexo -vhexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64... 至此，相关软件的安装全部完成。这个过程看似复杂，但实际操作起来非常简单：Git 和 Node.js 均有图形安装界面，基本上只需一直 “Next” 即可，而 Hexo 的安装也只是输入 npm install -g hexo-cli 一行命令而已。一切顺利的话，大约几分钟之内就能搞定。 现在，可以开始使用 Hexo 来构建你的专属博客站点了。 建立本地博客站点打开资源管理器，并在你打算存放博客站点的位置（例如 D:\\）中右击并选择 “Git Bash Here”，输入如下命令来让 Hexo 以指定的名称（例如 blog）创建一个文件夹，并将其初始化为 Hexo 博客站点： $ hexo init blogINFO Cloning hexo-starter to D:\\blogCloning into 'D:\\blog'......$ cd blog$ npm install...up to date in 8.258s 返回命令提示符后，表明基本的博客站点已准备就绪。 在资源管理器中查看 blog 文件夹，可发现 Hexo 已自动生成了站点所需的大量内容（如下图）。关于这些文件夹和文件的说明，详见 Hexo 的相关文档。 提示：如果你计划将站点部署到 GitHub 上，则不妨将博客站点文件夹命名为 &lt;username&gt;.github.io 的形式（其中 &lt;username&gt; 是你在 GitHub 上的用户名，下同），以便在本地设备和网络服务间保持一致。 预览本地博客站点启动 Hexo 本地服务器，看看运行中的博客站点是什么样子： $ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开浏览器，在地址栏中输入上面命令中提示的 http://localhost:4000 并回车。一切正常的情况下，就可以看到期待已久的博客站点了（如下图）。Hexo 非常贴心，默认时已经有一篇名为 “Hello World” 的文章，其内容主要是 Hexo 的文档链接，以及几个常用命令的简要说明。 提示：若浏览器无法显示上述地址，可能是 4000 端口已被占用。要解决这个问题，可按 “Ctrl+C” 关闭 Hexo 现有的服务器，然后尝试以其它端口重新启动服务器。 &gt; $ hexo server -p 4001&gt; INFO Start processing&gt; INFO Hexo is running at http://localhost:4001/. Press Ctrl+C to stop.&gt; 配置你的专属信息博客站点已经可以正常运行，但美中不足的是它还不是你专属的博客：网站标题为 “Hexo”，作者为 “John Deo”。要定义你自己的专属信息，可打开站点配置文件（blog/_config.yml），根据下面的 # 注释结合你的实际情况，修改 # Site 的相关选项（必要时添加server并指定自定义的端口），然后保存文件： # Sitetitle: ## 你的站点标题subtitle: ## 你的站点副标题description: ## 你的站点描述（关键字）author: ## 你的名字（作者）language: zh-CN ## 让界面按钮等以中文显示# Server（若 4000 端口确已被占用，可在最后增加这个配置）server: port: 4001 提示：站点配置文件文件采用了 YAML 语言格式，对于内容格式有严格要求，输入时请注意正确缩进，并且在每个 : 之后保留一个空格。 在 Git Bash 中重新启动服务器，再刷新浏览器中的博客站点，可以看到博客站点已真正变成你的专属博客，并且部分界面元素也显示为中文了。 恭喜你！你的专属博客站点已经搭建完毕。现在你可以开始撰写你的博客文章了。 不过，目前的博客站点仍局限在本地，还无法让任何人随时随地通过互联网来访问和阅读。并且，我们还需要未雨绸缪，对博客站点的文章源码及相关配置进行备份，以便万一在本地系统出现故障后，我们仍然能够迅速而又完整地取回博客站点的原始数据。 为此，我们还需要再做一点努力。 博客站点的远程部署实现博客站点的远程部署，显然你需要有一个远程仓库，用来存放已发布的文章，同时也用于备份所有博文的源码及整个博客站点的配置。 创建远程仓库访问 GitHub.com 并注册一个用户，通过邮件激活后登录，然后生成并上传你的 SSH 公钥。 在 GitHub 上创建名为 &lt;username&gt;.github.io 的仓库，注意其中的 &lt;username&gt; 是你在 GitHub 上的用户名，并且用户名之后还应该有 .github.io（不是 .com）。 进入该仓库的 Settings 页面，在 Options | GitHub Pages 部分可看到：GitHub Pages is currently disabled. You must first add content to yourrepository before you can publish a GitHub site。这表明，你必须把本地博客站点部署到这个远程仓库上，才能访问你的 GitHub Pages 主页。 提示：GitHub Pages 是你在 GitHub 上的用户 / 组织或项目的主页，每个 GitHub 用户 / 组织只能有一个用户 / 组织主页，但可以有数量不限的项目主页。GitHub Pages 基于相应的 GitHub 用户或仓库，只需把编辑后的内容推送到仓库，主页的内容即可自动更新。 部署前的准备在使用 Hexo 把博客站点部署到 GitHub 之前，还必须先安装部署工具，并对要部署的内容及目标位置进行一些配置。 安装部署工具对应于 Git 的 Hexo 部署工具是 “hexo-deployer-git”。在 blog 文件夹中打开 Git Bash，并输入如下命令来安装这个部署工具（从输出结果中可以看到，当前 hexo-deployer-git 的版本为 0.31）： $ npm install hexo-deployer-git --save...+ hexo-deployer-git@0.3.1added 31 packages in 16.036s 配置部署选项再次打开此前修改站点专属信息的配置文件（blog/_config.yml），找到 deploy 部分，并输入如下配置： deploy: - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: src extend_dirs: / ignore_hidden: false ignore_pattern: public: . 采用上述配置，Hexo 将在执行一键部署时，一次性把已发表的博客文章推送到远程仓库的 master 分支，同时把文章源码及站点相关设置推送到 src 分支： 提示：关于各部署选项的详细说明，请参阅 hexo-deployer-git 在 GitHub 上的说明。 执行部署与备份现在，终于可以进行一键部署了。在 blog 文件夹中打开 “Git Bash”，并运行如下命令。在一大堆输出的最后，出现了 INFO Deploy done: git 并返回提示符 $，表示部署完毕： $ hexo deploy...INFO Deploy done: git 博客站点的远程部署已经完成，赶快拿起你的手机（正在使用的电脑也可以），打开浏览器，输入 https://&lt;username&gt;.github.io 并进入。不出意料的话，你应该可以看到此前在本地服务器上看到的 “Hello World” 页面。 在 GitHub 上打开你的 &lt;username&gt;.github.io 仓库。进入 master 分支，可看到已发布的博客文章；进入 src 分支，可看到存放博文源码的 source 文件夹，刚刚修改过的 _config.yml，以及 .gitignore 等等与站点配置相关的文件夹和文件等。由此，你可以确认，本地站点的所有有效内容，都已推送并备份至远程仓库。 从此，你只需在每次新建或修改文章、或者是改变站点的配置之后，简单地执行一次部署，就可确信就算末日来临，你的专属博客的一切都不会丢失。甚至，如果你比我还懒的话，部署时可以输入简化的 hexo d -g 命令。 把博客部署到码云什么？你觉得 GitHub 速度太慢，并且有时候可能被墙导致无法访问？或许，你应该试试国内的代码托管网站 码云。 码云也提供了类似的 Pages 服务，托管你的博客的套路与也 GitHub 差不多：同样需要注册激活登录，上传 SSH 公钥，然后创建 &lt;username&gt; 项目（注意：与 GitHub 不同的是，不需要也不可以有 gitee.io 后缀）；进入项目页面选择 “服务 | Pages”, 再选择 “master” 分支并单击 “启动服务”。这样，码云的远程仓库就准备好了。 接着，把站点配置文件 deploy 部分的 repo 修改为包含 github 和 gitee 两个子节点，并在子节点的定义中指定远程仓库的地址及目标分支。这样，你就可以一次性地把你的博客站点同时部署到 GitHub 和码云上了。 deploy: - type: git repo: github: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git,master gitee: git@gitee.com:&lt;username&gt;/&lt;username&gt;.git,master - type: git repo: github: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git,src gitee: git@gitee.com:&lt;username&gt;/&lt;username&gt;.git,src extend_dirs: / ignore_hidden: false ignore_pattern: public: . 警告：repo 子节点的仓库地址和分支之间只有一个逗号（,），不能有空格。否则将出现 fatal: remote part of refspec is not a valid name in HEAD: master 错误，并且部署中断。 在浏览器中访问 &lt;username&gt;.gitee.io（没错，这里需要 gitee.io），就可以访问你部署在码云上的博客了。 多设备同步把博客站点部署到远程仓库后，你发表的博客文章已经可以随处阅读了。但是，你还想在公司在家里在路上在洗手间…… 在浴缸里撰写并发表博客，又该怎么办？ 这好办！ 克隆远程仓库找另一台电脑，没有的话，在本机上找一个临时文件夹也行。在希望存放本地博客站点的位置打开 “Git Bash”，然后输入如下命令来把远程仓库克隆到 blog 目录中： $ git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git blogCloning into '&lt;username&gt;.github.io'...... done. 提示：若要从码云上克隆仓库，则使用 git clone git@gitee.com:&lt;username&gt;/&lt;username&gt;.git blog 命令。 在资源管理器中打开克隆到的 blog 文件夹，并查看其内容： 怎么回事？这个克隆仓库中，居然只有已发表的博客文章。说好的源码呢？精心挑选的主题呢？复杂难解的站点配置都到哪去了？别担心，它们就在仓库里。你要做的，只是进入本地的克隆仓库，并切换到 src 分支： $ cd blog$ git checkout srcSwitched to branch 'src'Your branch is up to date with 'origin/src'. 再次查看 blog 文件夹的内容，谢天谢地，终于都回来了： 重新初始化本地站点不过，先别高兴得太早。克隆下来的文件夹中，并不包含运行 Hexo 所需的 node_modules 文件夹及 db.json 文件。为此，可退回在 blog 的上级目录，并按前面 “建立本地博客站点” 所述的方式，初始化一个临时的博客站点： cd ..$ hexo init temp_hexoINFO Cloning hexo-starter to D:\\temp\\temphexo...$ cd temp_hexo$ npm install 然后，在资源管理器中，拷贝 temp_hexo 文件夹中的全部文件，并粘贴到 blog 文件夹中（注意：必须先在 blog 切换到 src 分支）。当出现 “同名文件” 提示时，切记选择 “跳过这些文件”，以便保留来自远程仓库的站点最新内容及配置。 为稳妥起见，可参照前面 “测试本地博客站点” 的方式，启动 Hexo 服务器并在浏览器中检查博客的内容是否正确。再打开 _config.yml 并查看自定义的配置（例如前面的部署配置）是否仍然存在，而不是被覆盖为刚刚初始化的站点设置。 一切检查无误之后，你就可以在新设备上撰写和部署你的博客了。 尾声折腾了这么久，你终于可以、也应该写一篇博客了吧？如果你一时半会儿想不出来要写什么，那么这个折腾过程本身就是一个不错的主题。如果你还是嫌麻烦，至少也应该写一篇最为短小精悍的博文，并在其中只包含一个指向本文的链接吧。 至于如何流畅快速地创建、撰写和管理博文，请参阅 《VS Code，打造沉浸式的Hexo写作环境》，或者是看看官方文档的 “写作” 部分。 现在，如果你又修改了站点的内容，无论是修改了站点配置，还是撰写了新的博文，你都应该马上执行一次部署，以免意外丢失你的工作。然后，你就可以安心休息了……","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://dc1y.github.io/categories/实用工具/"},{"name":"Hexo","slug":"实用工具/Hexo","permalink":"https://dc1y.github.io/categories/实用工具/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dc1y.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://dc1y.github.io/tags/GitHub/"},{"name":"码云","slug":"码云","permalink":"https://dc1y.github.io/tags/码云/"}]}]}