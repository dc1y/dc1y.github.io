{"meta":{"title":"dc1y","subtitle":"笃行信道，自强不息","description":"Python, Hexo, Git","author":"czq","url":"https://dc1y.github.io"},"pages":[{"title":"关于我","date":"2018-03-14T03:44:22.000Z","updated":"2018-03-14T03:45:18.098Z","comments":true,"path":"about/index.html","permalink":"https://dc1y.github.io/about/index.html","excerpt":"","text":"本来并无寂静汽笛刺耳如利刃划破水面 刀过水依然无痕声逝寂静却浸透了每个角落"}],"posts":[{"title":"【Python 与模式】外观模式","slug":"python-facade-pattern","date":"2018-04-03T06:22:06.000Z","updated":"2018-04-03T06:22:06.000Z","comments":true,"path":"python-facade-pattern/","link":"","permalink":"https://dc1y.github.io/python-facade-pattern/","excerpt":"","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 11: Python Design Patterns II。 外观模式旨在为一个复杂的组件系统提供一个简单的接口。对于复杂的任务，我们可能必须跟这些对象直接交互，但这样的系统通常有一些 “典型” 用法，并不需要复杂的交互。外观模式允许我们定义一个新对象，用来封装系统的典型用法。每次需要访问常用功能时，可使用这个对象的简化接口。若项目的其它部分需要访问更为复杂的功能，仍然可以直接与系统交互。外观模式的 UML 图完全依赖于子系统，但大致如下： 外观对象在许多方面类似于适配器。主要区别是外观试图从复杂的接口中抽象出一个简化接口，而适配器只是尝试把一个现有的接口映射到另一个。 让我们来为一个 email 应用编写一个简单的外观。如我们在第 7 章所见，在 Python 中发送 email 的底层库相当复杂。而两个接收消息的库甚至更糟。 要是有一个简单的类就好了，它可让我们发送邮件，并列出 IMAP 或 POP3 连接上的当前收件箱中的邮件。为保持示例简短，我们采用了 IMAP 和 SMTP：这是两个处理 email 的完全不同的子系统。我们的外观只执行两个任务：发送一封邮件到指定地址，以及检查 IMAP 连接上的收件箱。它做了一些常见的假设，例如 SMTP 和 IMAP 的主机为同一地址，两者的用户名和密码相同，并且都使用了标准端口。这个外观覆盖了许多邮件服务器的场景，但若某个程序员需要更灵活的方式，仍可绕过外观并直接访问这两个子系统。 外观类使用了邮件服务器的主机名、登录用的用户名和密码来初始化： import smtplibimport imaplibclass EmailFacade: def __init__(self, host, username, password): self.host = host self.username = username self.password = password send_email 方法格式化邮件地址和消息，并使用 smtplib 进行发送。这个任务并不复杂，但需要把传入外观的 “自然” 参数进行一些处理，以便以正确的格式提供给 smtplib 进行发送： def send_email(self, to_email, subject, message): if not \"@\" in self.username: from_email = \"&#123;0&#125;@&#123;1&#125;\".format(self.username, self.host) else: from_email = self.username message = (\"From: &#123;0&#125;\\r\\n\" \"To: &#123;1&#125;\\r\\n\" \"Subject: &#123;2&#125;\\r\\n\\r\\n&#123;3&#125;\").format( from_email, to_email, subject, message) smtp = smtplib.SMTP(self.host) smtp.login(self.username, self.password) smtp.sendmail(from_email, [to_email], message) 方法开头的 if 语句，用于检查 username 是完整的发件人邮箱地址，还是只有 @ 左边部分；不同的主机的登录细节会有区别。 最后，获取当前收件箱中的消息的代码相当混乱；IMAP 协议过度设计了，而 imaplib 标准库只是该协议的一层薄封装： def get_inbox(self): mailbox = imaplib.IMAP4(self.host) mailbox.login(bytes(self.username, 'utf8'), bytes(self.password, 'utf8')) mailbox.select() x, data = mailbox.search(None, 'ALL') messages = [] for num in data[0].split(): x, message = mailbox.fetch(num, '(RFC822)') messages.append(message[0][1]) return messages 现在，把这些代码放在一起，我们就有了一个简单的外观类，可用相当直观的方式来发送和接收消息，比与这些复杂的库直接交互要简单得多。 尽管在 Python 社区中很少提及，但外观模式是 Python 生态不可或缺的一部分。因为 Python 强调语言的可读性，语言本身及其库倾向于为复杂的任务提供易于理解的接口。例如，for 循环、list 推导及生成器等，都是较为复杂的迭代器协议的外观。defaultdict 的实现是一个外观，它剥离了字典中不存在某个键的边际条件。第三方的 requests 库是一个强大的外观，封装了可读性较差的 HTTP 请求库。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"外观模式","slug":"外观模式","permalink":"https://dc1y.github.io/tags/外观模式/"}]},{"title":"【Python 与模式】适配器模式","slug":"python-adapter-pattern","date":"2018-04-03T03:33:47.000Z","updated":"2018-04-03T03:33:47.000Z","comments":true,"path":"python-adapter-pattern/","link":"","permalink":"https://dc1y.github.io/python-adapter-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 11: Python Design Patterns II。 与我们在第 8 章了解到的大多数模式不同，适配器模式用于与现有的代码交互。我们不会设计一组全新的、实现了适配器模式的对象。适配器用于让两个预先存在的对象一起工作，即使它们的接口并不兼容。与可让 VGA 投影仪插入到 HDMI 端口的显示适配器一样，适配器对象居于两个不同接口之间，并在它们之间进行实时转换。适配器对象的唯一目的就是执行这些转换。适配时可能涉及许多任务，如转换参数格式、重新安排参数次序、调用命名不同的方法，或者是提供默认参数等。 在结构方面，适配器模式类似于简化的装饰器模式。装饰器一般提供它们所替换的同名接口，而适配器则在两个接口间进行映射。下面是 UML 图：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 11: Python Design Patterns II。 与我们在第 8 章了解到的大多数模式不同，适配器模式用于与现有的代码交互。我们不会设计一组全新的、实现了适配器模式的对象。适配器用于让两个预先存在的对象一起工作，即使它们的接口并不兼容。与可让 VGA 投影仪插入到 HDMI 端口的显示适配器一样，适配器对象居于两个不同接口之间，并在它们之间进行实时转换。适配器对象的唯一目的就是执行这些转换。适配时可能涉及许多任务，如转换参数格式、重新安排参数次序、调用命名不同的方法，或者是提供默认参数等。 在结构方面，适配器模式类似于简化的装饰器模式。装饰器一般提供它们所替换的同名接口，而适配器则在两个接口间进行映射。下面是 UML 图： 在这里，Interface1 想要调用 make_action(some, arguments)。我们已经有 Interface2 类可完成所需的任务（为避免重复，我们不想重新编写这个类），但它提供的方法却是 different_action(other, arguments)。Adapter 类实现了 make_action 接口，并将其参数映射到现有的接口。 这种方式的优点是，把一个接口映射到另一个接口的代码全部在一个位置。其它的方案可能相当丑陋；我们不得不在每个需要访问这些代码的地方，在多个位置执行转换。 例如，假定我们已有了如下的类，它接受 “YYYY-MM-DD” 格式的字符串日期，并计算某个人在指定日期的年龄： class AgeCalculator: def __init__(self, birthday): self.year, self.month, self.day = ( int(x) for x in birthday.split('-')) def calculate_age(self, date): year, month, day = ( int(x) for x in birthday.split('-')) age = year - self.year if (month, day) &lt; (self.month, self.day): age -= 1 return age 这是一个相当简单的类，它完成了应该完成的任务。但我们对这个程序员的考虑感到惊讶，他使用了特殊格式的字符串、而不是 Python 的极其有用的内置 datetime 库。作为一个尽可能重用代码的尽责的程序员，我们编写的大多数程序都将与 datetime 对象交互，而不是字符串。 我们有几种选择来解决这种情况；可以把类重写为接受 datetime 对象，这样至少会更加精确。但若这个类来自于第三方，并且我们不知道或不能改变其内部结构，就只能尝试其它方式了。我们可以按原样使用这个类，并在每次需要根据 datetime.date 对象计算年龄时，调用 datetime.date.strftime(&#39;%Y-%m-%d&#39;) 来将其转换为适当的格式。但这种转换可能发生在许多地方，更糟的是，若把 %m 误输为 %M，则将返回当前的分钟数而不是月份！想像一下你在许多地方都写错了，则改正时也非常麻烦。这不是可维护的代码，也违背了 DRY 原则。 相反，我们可编写一个适配器，以便可把普通的日期插入到 AgeCalculator 类中： import datetimeclass DateAgeAdapter: def _str_date(self, date): return date.strftime(\"%Y-%m-%d\") def __init__(self, birthday): birthday = self._str_date(birthday) self.calculator = AgeCalculator(birthday) def get_age(self, date): date = self._str_date(date) return self.calculator.calculate_age(date) 这个适配器把 datetime.date 和 datetime.time（均有同样的 strftime 接口）转换为可供 AgeCalculator 使用的字符串。现在我们就可以通过新的接口来使用原来的代码了。我把方法签名定为 get_age，以演示发起调用的接口也可以寻找不同的方法名，而不仅仅是采用不同类型的参数。 以这种方式创建一个适配器类，是实现适配器模式的常规方式，但，Python 照例有其它方式来做这个事情。继承和多重继承可用于向类添加功能。例如，我们可以在 date 类上添加一个适配器，以便它可以与原来的 AgeCalculator 类一起工作： import datetimeclass AgeableDate(datetime.date): def split(self, char): return self.year, self.month, self.day 这样的代码令人怀疑其在 Python 中是否合法。我们在子类中添加了一个 split 方法，接受一个参数（但未使用，只为满足split方法的要求）并返回年、月和日的元组。这个类完全可以与原来的 AgeCalculator 一起工作，因为后者的代码对一个特殊格式的字符串调用了 split（原文为 strip，疑误），并返回一个包含年月日的元组。AgeCalculator 的代码只关注 split 是否存在且返回适当的值；它不关心我们是否真的传入了字符串。这个类确实可以正常工作： &gt;&gt;&gt; bd = AgeableDate(1975, 6, 14)&gt;&gt;&gt; today = AgeableDate.today()&gt;&gt;&gt; todayAgeableDate(2015, 8, 4)&gt;&gt;&gt; a = AgeCalculator(bd)&gt;&gt;&gt; a.calculate_age(today)40 虽然可以工作但却是愚蠢的做法。在这个特定的例子中，这个适配器很难维护。我们很快就会忘记为什么要给 date 类添加一个 split 方法。这个方法的名称含义模糊。这可能是适配器的通病，但显式创建一个适配器、而不是使用继承，通常可澄清其用途。 除继承外，有时也可以使用猴子补丁来向现有的类添加一个方法。这种方式不适合于 datetime 对象，因为它不允许在运行时添加属性，但在普通的类中，我们可以添加一个新方法，并提供发起调用的代码所需的适配接口。或者，也可以扩展 AgeCalculator 本身或对其应用猴子补丁，用更适合我们需要的方法来替换掉 calculate_age 方法。 最后，通常还可以使用函数来充当适配器；这似乎与适配器模式的实际设计不太吻合，但若记得函数实质上只是带有 __call__ 方法的对象，则函数就会成为一种明显的适配器。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://dc1y.github.io/tags/适配器模式/"}]},{"title":"【Python 与模式】策略模式","slug":"python-template-pattern","date":"2018-04-02T09:33:19.000Z","updated":"2018-04-02T09:33:19.000Z","comments":true,"path":"python-template-pattern/","link":"","permalink":"https://dc1y.github.io/python-template-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 模板模式对于移除重复代码很有用；它是一种支持第 5 章所讨论的 DRY（Don’t Repeat Yourself）原则的实现。它是为几个要完成的任务有着一些共同步骤的情况而设计的。这些共同步骤在基类中实现，而不同的步骤则在子类中重写，以提供自定义的行为。在某种程度上，它类似于泛化的策略模式，但算法的相似部分使用一个基类来共享。下面是该模式的 UML 图：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 模板模式对于移除重复代码很有用；它是一种支持第 5 章所讨论的 DRY（Don’t Repeat Yourself）原则的实现。它是为几个要完成的任务有着一些共同步骤的情况而设计的。这些共同步骤在基类中实现，而不同的步骤则在子类中重写，以提供自定义的行为。在某种程度上，它类似于泛化的策略模式，但算法的相似部分使用一个基类来共享。下面是该模式的 UML 图： 模板的示例让我们创建一个销售报告作为例子。我们可以把销售记录存储在一个 SQLite 数据库表中。SQLite 是一个基于文件的数据库引擎，允许我们使用 SQL 语法来存储记录。Python 3 在标准库中包含了 SQLite，因此不需要其它模块。 我们有两个共同的任务需要执行： 选择所有新车的销售，并以逗号分隔的格式输出到屏幕 以逗号分隔输出所有销售人员的列表，以及他们的销售总额，并保存为一个可导入到电子表格的文件 这看来像是区别很大的任务，但它们有一些共同的特征。在这两种情况下，我们需要执行如下步骤： 连接到数据库。 为新车或信息总额构建一个查询。 执行查询。 把结果格式化为以逗号分隔的字符串。 把数据输出到文件或电邮。 这两个任务的查询构建和输出两个步骤是不同的，但其余步骤则完全相同。我们可以使用模板模式来把这些共同的步骤放在一个基类中，而有变化的步骤则放入两个子类。 开始之前，让我们用几行 SQL 来创建一个数据库，并存入一些示例数据： import sqlite3conn = sqlite3.connect(\"sales.db\")conn.execute(\"CREATE TABLE Sales (salesperson text,\" \"amt currency, year integer, model text, new boolean)\")conn.execute(\"INSERT INTO Sales values\" \"('Tim', 9000, 2006,'Ford Focus','false'\")conn.execute(\"INSERT INTO Sales values\" \"('Gayle', 8000, 2004,'Dodge Neon','false')\")conn.execute(\"INSERT INTO Sales values\" \"('Gayle', 28000, 2009,'Ford Mustang','true')\")conn.execute(\"INSERT INTO Sales values\" \"('Gayle', 50000, 2010,'Lincoln Navigator','true')\")conn.execute(\"INSERT INTO Sales values\" \"('Don', 20000, 2008,'Toyota Prius','false')\")conn.commit()conn.close() 即使不懂 SQL，可能你也能看出这里做了什么；我们创建了一个表来存储数据，并使用六个插入语句来添加销售记录。数据被存储在一个名为 sales.db 的文件中。现在我们就有了可在开发模板模式中使用的样本了。 由于我们已经概括了模板应该执行的步骤，我们可以从定义包含这些步骤的基类开始。每个步骤都有自己的方法（以便有选择地重写任一步骤），还有一个管理性的方法依次调用这些步骤。不带方法内容的代码大致如下： class QueryTemplate: def connect(self): pass def construct_query(self): pass def do_query(self): pass def format_results(self): pass def output_results(self): pass def process_format(self): self.connect() self.construct_query() self.do_query() self.format_results() self.output_results() process_format 方法是被外部客户调用的主方法。它确保每个步骤按次序执行，但不关注步骤是在本类还是子类中实现的。对于本例，我们知道有三个方法在两个子类中是一样的： def connect(self): self.conn = sqlite3.connect(\"sales.db\")def construct_query(self): raise NotImplementedError()def do_query(self): results = self.conn.execute(self.query) self.results = results.fetchall()def format_results(self): output = [] for row in self.results: row = [str(i) for i in row] output.append(\",\".join(row)) self.formatted_results = \"\\n\".join(output)def output_results(self): raise NotImplementedError() 为帮助子类的实现，两个未细化的方法抛出了 NotImplementedError。当抽象基类过于臃肿时，这是在 Python 中指定抽象接口的常用方式。方法也可以只有空实现（使用 pass），或者是完全没有定义。但抛出 NotImplementedError 有助于程序员理解这个类需要进行子类化并重写这些方法；空方法或不存在的方法很难被认出来需要实现，并且在未实现这些方法时需要调试。 现在我们有了模板类来处理繁琐的细节，但也可灵活执行和格式化各种各样的查询。最好的是，若我们需要把数据库引擎从 SQLite 改变为其它引擎（如 py-postgresql），我们只需修改模板类，而不必触及我们已经写好的两个（或两百个）子类。 现在让我们看看具体类： import datetimeclass NewVehiclesQuery(QueryTemplate): def construct_query(self): self.query = \"select * from Sales where new='true'\" def output_results(self): print(self.format_results)class UserGrossQuery(QueryTemplate): def construct_query(self): self.query = (\"select salesperson, sum(amt)\" + \"from Sales group by salesperson\") def output_results(self): filename = \"gross_sales_&#123;0&#125;\".format( datetime.date.today().strftime(\"%Y%m%d\") ) with open(filename, 'w') as outfile: outfile.write(self.formatted_results) 这两个类实际上非常短，考虑一下你做了什么：连接到数据库，执行查询，格式化结果并输出它们。超类负责了重复性的工作，但让我们轻松指定那些不同的步骤。此外，我们还可以轻易改变基类中的步骤。例如，如果想输出不是以逗号分隔的字符串（例如：要上传到网站的 HTML 报告），仍然可通过重写 format_results 来实现。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"https://dc1y.github.io/tags/策略模式/"}]},{"title":"【Python 与模式】单例模式","slug":"python-singleton-pattern","date":"2018-04-02T07:25:15.000Z","updated":"2018-04-02T07:25:15.000Z","comments":true,"path":"python-singleton-pattern/","link":"","permalink":"https://dc1y.github.io/python-singleton-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 单例模式是最有争议的模式；许多人指其为一种 “反模式”，即应避免采用和发扬的模式。在 Python 中，若有人使用了单例模式，则几乎肯定是犯了错，因为他们来自于某种限制较严的编程语言。 那还有什么讨论的必要呢？单例是最出名的设计模式之一。它在极度面向对象的语言中很有用，也是传统面向对象编程的关键部件。更贴切地说，单例背后的概念很有用，即使我们在 Python 中以完全不同的方式来实现这个概念。 单例模式背后的基本概念，是让某个对象只能有唯一的实例存在。一般来说，这个对象是某种类似于我们在第 5 章讨论的管理器类。这种对象通常需要被大范围的其它对象引用，并把管理器对象的引用传递给各种需要它的方法和构造器，这样可能让代码变得难于阅读。 相反，若使用了单例，则各对象从单例类中请求管理器对象的单一实例，因此无需将其引用四处传递。下面的 UML 图未能完全描述这个过程，但在此提供以确保完整性：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 单例模式是最有争议的模式；许多人指其为一种 “反模式”，即应避免采用和发扬的模式。在 Python 中，若有人使用了单例模式，则几乎肯定是犯了错，因为他们来自于某种限制较严的编程语言。 那还有什么讨论的必要呢？单例是最出名的设计模式之一。它在极度面向对象的语言中很有用，也是传统面向对象编程的关键部件。更贴切地说，单例背后的概念很有用，即使我们在 Python 中以完全不同的方式来实现这个概念。 单例模式背后的基本概念，是让某个对象只能有唯一的实例存在。一般来说，这个对象是某种类似于我们在第 5 章讨论的管理器类。这种对象通常需要被大范围的其它对象引用，并把管理器对象的引用传递给各种需要它的方法和构造器，这样可能让代码变得难于阅读。 相反，若使用了单例，则各对象从单例类中请求管理器对象的单一实例，因此无需将其引用四处传递。下面的 UML 图未能完全描述这个过程，但在此提供以确保完整性： 在大多数编程环境中，单例被强制为其构造器是私有的（因此不能再创建额外的实例），然后提供一个静态方法来获取这个单一的实例。这个方法在首次被调用时创建一个新实例，并在后续的每一次调用中返回这个实例。 单例的实现Python 没有私有的构造器，但针对这种情况有更好的做法。我们可以使用 __new__ 类方法来确保只能创建一个实例： class OneOnly: _singleton = None def __new__(cls, *args, **kwargs): if not cls._singleton: cls._singleton = super(OneOnly, cls).__new__(cls, *args, **kwargs) return cls._singleton 当 __new__ 被调用时，通常会构建相应类的一个实例。我们重写了这个方法，首先检查单例实例是否已经创建；若未创建，则通过 super 调用进行创建。这样，每当我们调用 OneOnly 的构造器时，总是得到完全相同的实例： &gt;&gt;&gt; o1 = OneOnly()&gt;&gt;&gt; o2 = OneOnly()&gt;&gt;&gt; o1 == o2True&gt;&gt;&gt; o1&lt;__main__.OneOnly object at 0xb71c008c&gt;&gt;&gt;&gt; o2&lt;__main__.OneOnly object at 0xb71c008c&gt; 这两个对象是相等的，且位于相同的地址；因此它们是同一个对象。这种特殊的实现不是很透明，因为没有明显表示创建了一个单例对象。当我们调用构造器时，通常期待生成对象的一个新实例；这种做法违背了这个契约。若确实需要单例的话，详尽的文档字符串或可缓解这个问题。 但我们不需要这种做法。Python 人不会强制代码的用户进入特定的思维模式。我们可能觉得永远只需要一个类实例，但其他程序员可能有别的观点。例如，单例可能会妨碍分布式计算、并行编程和自动测试。在这些情况中，有某个特定对象的多个或替代实例可能很有用，即使 “正常” 的操作并不需要更多的实例。 模块变量可模拟单例。 在 Python 中，通常可用模块级的变量来模拟单例模式。这不如单例那么 “安全”，因为可随时对这些变量进行重新赋值，但这与我们在第 2 章讨论的私有变量一样，在 Python 中是可以接受的。若有人有充足的理由改变这些变量，为什么要阻止他们？模块变量也不能阻止人们实例化该对象的多个实例，但还是一样，若有人有充足的理由这么做，何必去阻止他们？ 理想情况下，我们应向他们提供一种机制来获取 “默认的单例” 值，同时也允许他们在需要时创建其它实例。尽管技术上完全不是单例，但却为类单例行为提供了最 Python 式的机制。 要使用模块级变量来代替单例，可在定义一个类之后创建它的一个实例。我们可以把状态模式改进为使用单例。取代在每次改变状态时创建一个新对象，我们可以创建一个始终可以访问的模块级变量： class FirstTag: def process(self, remaining_string, parser): i_start_tag = remaining_string.find('&lt;') i_end_tag = remaining_string.find('&gt;') tag_name = remaining_string[i_start_tag+1:i_end_tag] root = Node(tag_name) parser.root = parser.current_node = root parser.state = child_node return remaining_string[i_end_tag+1:]class ChildNode: def process(self, remaining_string, parser): ...class OpenTag: def process(self, remaining_string, parser): ...class TextNode: def process(self, remaining_string, parser): ...class CloseTag: def process(self, remaining_string, parser): ...first_tag = FirstTag()child_node = ChildNode()text_node = TextNode()open_tag = OpenTag()close_tag = CloseTag() 我们所做的，就是创建各种状态类的可供重用的实例。注意我们在类中访问了这些模块变量，即使这些变量尚未定义。这是因为类中的代码在方法被调用前不会执行，而到了调用时，整个模块也都已定义完成了。 本例的区别是，取代浪费内存创建一堆需要进行垃圾回收的新实例，我们重用了每种状态的单一状态对象。即使同时运行多个解析器，也只需要使用这些状态类。 当初在创建基于状态的解析器时，你可能奇怪我们为何不把解析器对象传递给各个状态的 __init__，而是将其传递给 process 方法。将解析器传递给各状态，就可通过 self.parser 来引用它。这对于状态模式的实现来说没有问题，但可能导致无法利用单例模式。若状态对象维护着一个对解析器的引用，则将无法用于同时引用其它解析器。 记住，这是两种不同用途的不同模式；单例模式对于实现状态模式很有用，并不意味着这两种模式是相关的。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://dc1y.github.io/tags/单例模式/"}]},{"title":"【Python 与模式】状态模式","slug":"python-state-pattern","date":"2018-04-02T02:43:44.000Z","updated":"2018-04-02T02:43:44.000Z","comments":true,"path":"python-state-pattern/","link":"","permalink":"https://dc1y.github.io/python-state-pattern/","excerpt":"提示 ：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 状态模式在结构上类似于策略模式，但其意图和目的则区别很大。状态模式的目标是表达一个状态迁移系统：对象可明显处于某种特定状态，且某些动作可将其推向另一状态的系统。 在状态模式中，我们需要一个管理器，或者是上下文类来提供一个切换状态的接口。在内部，这个类包含一个指向当前状态的指针；每个状态都知道可以进入其余的哪些状态，并根据所发生的动作来迁移到这些状态。 因此，我们需要两种类，上下文类及多个状态类。上下文类维护当前的状态，并把动作委托给状态类。相对于调用上下文的对象来说，状态类一般是隐藏的；就像一个在内部执行状态管理的黑匣子。下面是状态模式的 UML 图：","text":"提示 ：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 状态模式在结构上类似于策略模式，但其意图和目的则区别很大。状态模式的目标是表达一个状态迁移系统：对象可明显处于某种特定状态，且某些动作可将其推向另一状态的系统。 在状态模式中，我们需要一个管理器，或者是上下文类来提供一个切换状态的接口。在内部，这个类包含一个指向当前状态的指针；每个状态都知道可以进入其余的哪些状态，并根据所发生的动作来迁移到这些状态。 因此，我们需要两种类，上下文类及多个状态类。上下文类维护当前的状态，并把动作委托给状态类。相对于调用上下文的对象来说，状态类一般是隐藏的；就像一个在内部执行状态管理的黑匣子。下面是状态模式的 UML 图： 状态示例为演示状态模式，让我们来建立一个 XML 解析工具。上下文类就是解析器本身。它将接受一个字符串作为输入，并把这个工具置于初始的解析状态。每一种状态都将 “吃掉” 一些字符，寻找某个特定值，并在找到这个值时，改变到其它状态。其目标是为每个标记及其内容创建一个节点对象树。为保持简单，我们将只解析 XML 标记及标记名的一个子集。这个工具将不处理标记上的属性。它将解析标记的文本内容，但不会试图解析在文本内包含标记的 “混合” 内容。下面是这个工具能够解析的一个 “简化版 XML” 文件的例子： &lt;book&gt; &lt;author&gt;Dusty Phillips&lt;/author&gt; &lt;publisher&gt;Packt Publishing&lt;/publisher&gt; &lt;title&gt;Python 3 Object Oriented Programming&lt;/title&gt; &lt;content&gt; &lt;chapter&gt; &lt;number&gt;1&lt;/number&gt; &lt;title&gt;Object Oriented Design&lt;/title&gt; &lt;/chapter&gt; &lt;chapter&gt; &lt;number&gt;2&lt;/number&gt; &lt;title&gt;Objects In Python&lt;/title&gt; &lt;/chapter&gt; &lt;/content&gt;&lt;/book&gt; 在着眼于状态和解析器之前，让我们考虑一下这个程序的输出。我们知道需要一个 Node 对象，但这个 Node 应该是怎么样的？嗯，显然它需要知道它所解析的标记的名称，并且由于它是一个树状结构，因此或许也应维护一个指向父节点的指针，以及一个有序的子节点清单。有些但并非所有节点都有文本值。让我们先来看看 Node 类： class Node: def __init__(self, tag_name, parent=None): self.parent = parent self.tag_name = tag_name self.children = [] self.text = \"\" def __str__(self): if self.text: return self.tag_name + \":\" + self.text else: return self.tag_name 这个类在初始化时设置了默认的属性值。提供了 __str__ 方法来在解析完成时可视化其树状结构。 现在，按照示例的说明，我们需要考虑解析器具备哪些状态。显然它应该从一个还没有处理任何节点的状态开始。我们还需要处理起始标记和结束标记的状态。当我们处于带文本标记的内部时，也必须有一个单独的状态来执行处理。 切换状态可能比较麻烦；我们怎么才能知道下一个节点是起始标记、结束标记，还是文本节点？我们可以在每种状态中加入一点逻辑来解决这个问题，但实际上更好的做法，是创建一个新的状态，其唯一的功能就是确定接着要切换到哪个状态。若将这个状态称为 ChildNode，则最终可得到如下状态： FirstTag ChildNode OpenTag CloseTag Text FirstTag 状态将切换到 ChildNode，后者负责决定切换到其余三种状态的哪一种；当那些状态完成处理后，就切换回到 ChildNode。下面的状态迁移图显示了可用的状态变化： 这些状态将接受 “剩余未处理的字符串”，尽可能多地处理它们能够解析的内容，然后告诉解析器继续处理余下的内容。让我们先来建立 Parser 类： class Parser def __init__(self, parse_string): self.parse_string = parse_string self.root = None self.current_node = None self.state = FirstTag() def process(self, remaining_string): remaining = self.state.process(remaining_string, self) # 上面的 state.process 在解析完成后，把 parser 切换到另一个状态， # 故下面的递归调用，将会执行新的 state.process 方法 if remaining: self.process(remaining) def start(self): self.process(self.parse_string) 初始化器在类中建立了几个供各状态访问的变量。parse_string 实例变量是我们将要解析的文本。root 节点是 XML 结构中的 “顶级” 节点。current_node 实例变量是当前向其添加子级的节点。 这个解析器的重要特征是其 process 方法，它接受剩余的字符串，并将其传递给当前状态。解析器本身（self 参数）也被传递给状态的 process 方法，以便状态能够访问并修改其变量。状态在完成处理后，必须返回剩余未解析的字符串。随后解析器递归地对剩余字符串调用 process 方法，以便建立余下的树状结构。 现在，让我们看看 FirstTag 状态： class FirstTag: def process(self, remaining_string, parser): i_start_tag = remaining_string.find('&lt;') i_end_tag = remaining_string.find('&gt;') tag_name = remaining_string[i_start_tag+1 : i_end_tag] root = Node(tag_name) parser.root = parser.current_node = root parser.state = ChildNode() return remaining_string[i_end_tag+1:] 这个状态找到第一个标记的开始和结束尖括号的索引号（i_ 表示 index）。你可能觉得这个状态是不必要的，因为 XML 要求在起始标记之前不应有文本。但是，此处却可能有空白字符需要忽略；这就是我们搜索开始尖括号、而不是假定它是文档中的第一个字符的原因。注意这段代码假定了文件是有效的输入。正式的实现应严格测试无效的输入，并尝试恢复或显示详尽的错误消息。 这个方法提取标记的名称，并将其赋值给解析器的根节点。同时也赋值给 current_node，因为它也是接下来要添加子级的节点。 然后就是实现的部分：方法把解析器的当前状态改变到 ChildNode 状态。随后返回剩余的字符串（从开始标记之后开始）以作进一步处理。 ChildNode 状态看似复杂，实际上只是一组条件语句： class ChildNode: def process(self, remaining_string, parser): stripped = remaining_string.strip() if stripped.startswith(\"&lt;/\"): parser.state = CloseTag() elif stripped.startswith(\"&lt;\"): parser.state = OpenTag() else: parser.state = TextNode() return stripped strip() 调用从字符串中移除空白字符。随后确定解析器的下一个状态是起始或结束标记，还是文本字符串。根据条件语句的结果，把解析器设定到某个特定状态，然后让它解析剩余的字符串。 OpenTag 状态类似于 FirstTag 状态，不同的是，它把新创建的节点添加到 current_node 对象的 children，并将其设定为新的 current_node。在继续之前，还把解析器再次设定为 ChildNode 状态： class OpenTag: def process(self, remaining_string, parser): i_start_tag = remaining_string.find('&lt;') i_end_tag = remaining_string.find('&gt;') tag_name = remaining_string[i_start_tag+1 : i_end_tag] node = Node(tag_name, parser.current_node) parser.current_node.children.append(node) parser.current_node = node parser.state = ChildNode() return remaining_string[i_end_tag+1:] CloseTag 状态的做法基本相反；它把解析器的 current_node 设置回父节点，以便外围标记的后续子级可添加到这个父节点： class CloseTag: def process(self, remaining_string, parser): i_start_tag = remaining_string.find('&lt;') i_end_tag = remaining_string.find('&gt;') assert remaining_string[i_start_tag+1] == \"/\" tag_name = remaining_string[i_start_tag+2 : i_end_tag] assert tag_name == parser.current_node.tag_name parser.current_node = parser.current_node.parent parser.state = ChildNode() return remaining_string[i_end_tag+1:].strip() 两个 assert 语句用于确认解析字符串的一致性。方法末尾的 if 语句（代码似乎有误）确保处理完成后终止程序。若节点的父级为 None，则意味着我们正在处理根节点。 最后，TextNode 只是简单地提取下一个结束标记之前的文本，并将其设置为当前节点的值： class TextNode: def process(self, remaining_string, parser): i_start_tag = remaining_string.find('&lt;') text = remaining_string[:i_start_tag] parser.current_node.text = text parser.state = ChildNode() return remaining_string[i_start_tag:] 现在，必须设置解析器对象的初始状态设置。初始状态是一个 FirstTag 对象，因此只需将下面语句添加到 __init__ 方法中： self.state = FirstTag() 要测试这个类，可添加一个主脚本来从命令行打开一个文件，执行解析，并打印生成的节点： if __name__ ==\"__main__\": import sys with open(sys.argv[1]) as file: contents = file.read() p = Parser(contents) p.start() nodes = [p.root] while nodes: node = nodes.pop(0) print(node) nodes = node.children + nodes 这段代码打开指定的文件，加载其内容，并解析出结果。然后依次打印每个节点及其子级。节点类的 __str__ 方法负责格式化节点以便打印。若对前面的 XML 例子运行这个脚本，其输出如下： bookauthor: Dusty Phillipspublisher: Packt Publishingtitle: Python 3 Object Oriented Programmingcontentchapternumber: 1title: Object Oriented Designchapternumber: 2title: Objects In Python 与原始的简化版 XML 的内容相对比，可发现解析器的确可以工作。 状态与策略的对比状态模式看起来与策略模式非常相似；的确，它们的 UML 图是相同的。它们的实现也是相同的；我们甚至可以使用第一级函数来充当状态，而不是把它们包裹在对象中，就像在策略模式中那样。 尽管这两种模式有相同的结构，但它们解决的是完全不同的问题。策略模式用于在运行时选择一种算法；一般来说，只能从算法中选择其中之一来处理特定的用例。而状态模式的主旨，在于随着某个过程的进展，而动态地在不同状态间切换。在代码中，主要区别是策略模式通常并不知道其它策略对象。但在状态模式中，状态及上下文都需要知道它们可以切换到其余的哪一个状态。 状态迁移作为协同程序状态模式是针对状态迁移问题的标准面向对象解决方案。然而，这个模式的代码相当繁琐。你可以通过把对象构建为协同程序来得到类似的效果。还记得我们在第 9 章建立的正则表达式日志文件解析器吗？这就是一个隐晦的状态迁移问题，其实现与定义状态模式所需的全部对象（或函数）的主要区别，在于协同程序解决方案可让我们把更多的样板代码编写在语言结构中。这是两种实现，没有哪一种天生优于另一种，但你可能会发现协同程序的可读性更好，相对于某种特定的 “可读性” 来说（你必须能够理解协同程序的语法）。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"状态模式","slug":"状态模式","permalink":"https://dc1y.github.io/tags/状态模式/"}]},{"title":"【Python 与模式】策略模式","slug":"python-strategy-pattern","date":"2018-03-31T13:29:39.000Z","updated":"2018-03-31T13:29:39.000Z","comments":true,"path":"python-strategy-pattern/","link":"","permalink":"https://dc1y.github.io/python-strategy-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 在面向对象编程中，策略模式常用于作为抽象的演示。这种模式针对一个问题实现了不同的解决方案，每个解决方案都是一个不同的对象。客户端代码可在运行时，动态地选择最合适的实现。 一般情况下，不同的算法有不同的权衡；某个算法可能比另一个算法更快，但使用更多的内存，而第三个算法则可能最适合于多 CPU 或分布式系统。下面是策略模式的 UML 图：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 在面向对象编程中，策略模式常用于作为抽象的演示。这种模式针对一个问题实现了不同的解决方案，每个解决方案都是一个不同的对象。客户端代码可在运行时，动态地选择最合适的实现。 一般情况下，不同的算法有不同的权衡；某个算法可能比另一个算法更快，但使用更多的内存，而第三个算法则可能最适合于多 CPU 或分布式系统。下面是策略模式的 UML 图： 连接到策略模式的 User 代码，只需知道它与 Abstraction 的接口交互。被选定的实际实现执行同样的任务，但采用了不同的方式；无论如何，接口都是相同的。 策略的示例策略模式的标准示例是排序程序；多年来，人们发明了对一个对象集合进行排序的众多算法；快速排序，归并排序和堆排序都是快速的排序算法，具有不同的特性并各有所长，这取决于输入的大小和类型，如何输出以及系统的需求。 如果我们有需要对一个集合进行排序的客户端代码，可给其传递一个带有 sort() 方法的对象。这个对象可以是 QuickSorter 或 MergeSorter 对象，但不管哪一个结果都一样：排序好的列表。用于执行排序的策略被从调用代码中抽象出来，使其成为可替换的模块。 当然，在 Python 中我们通常只需调用 sorted 函数或 list.sort 方法，并相信其将以近乎最优的方式执行排序。因此，我们确实需要一个更合适的例子。 让我们来考虑一个桌面墙纸管理器。当一张图像被显示在桌面背景时，它可以按不同的方式去适应屏幕的尺寸。例如，若图像小于屏幕，则可在屏幕上平铺、居中或放大到适应屏幕。还有其它更复杂的策略可供使用，如缩放至最大高度或宽度，将其组合到一个纯色的、半透明的或渐变的背景颜色，或者是其它操作。我们打算今后再添加这些策略，现在还是先从基本的策略开始。 我们的策略对象接受两个输入：要显示的图像，以及包含屏幕宽度和高度的一个元组。这些策略均根据屏幕尺寸返回一个新的图像，并且这个图像被指定的策略修改为与屏幕相适应。本例需要你运行 pip3 install pillow 来安装 pillow 模块： from PIL import Imageclass TiledStrategy: def make_background(self, img_file, desktop_size): in_img = Image.open(img_file) out_img = Image.new('RGB', desktop_size) num_tiles =[ o // i + 1 for o, i in zip(out_img.size, in_img.size) ] for x in range(num_tiles[0]): for y in range(num_tiles[1]): out_img.paste(in_img, ( in_img.size[0] * x, in_img.size[1] * y, in_img.size[0] * (x+1), in_img.size[1] * (y+1) )) return out_imgclass CenteredStrategy: def make_background(self, img_file, desktop_size): in_img = Image.open(img_file) out_img = Image.new('RGB', desktop_size) left = (out_img.size[0] - in_img.size[0]) // 2 top = (out_img.size[1] - in_img.size[1]) // 2 out_img.paste(in_img, ( left, top, left + in_img.size[0], top + in_img.size[1] )) return out_imgclass ScaledStrategy: def make_background(self, img_file, desktop_size): in_img = Image.open(img_file) out_img = in_img.resize(desktop_size) return out_img 这里我们有三个策略，每个策略都使用了 PIL 来执行它们的任务。各个策略都有一个 make_background 方法，该方法接受一组相同的参数。一经选定，相应的策略即被调用，并创建正确调整了大小的桌面图像。TiledStrategy 按输入图像铺满屏幕宽度和高度所需的数量进行循环，并在每个位置重复拷贝输入图像。CenteredStrategy 计算需要在四个边界留出多大的空间来让图像居中。ScaledStrategy 把图像强制调整为输出尺寸（忽略纵横比）。 考虑一下在没有策略模式下，该如何实现在这些选项间的切换。我们必须把所有代码放入到一个巨大的方法中，并使用笨拙的 if 语句来选择所需的选项。每次加入新的策略，都会让这个方法更笨重。 Python 中的策略前述策略模式的标准实现，尽管在许多面向对象的库中很常见，但在 Python 编程中却很少见。 这些类的对象，除提供一个函数外无所作为。我们可以将这个函数命名为 __call__，轻松将其变成一个可直接调用的对象。由于没有其它数据与该对象关联，我们所要做的，只不过是创建一组顶级函数，并把它们作为策略传入即可。 设计模式哲学的反对者会因此说，“因为 Python 有第一级的函数，因此策略模式是不必要的”。的确，Python 的第一级函数允许我们以更直接的方式实现策略模式。但了解该模式的存在，仍然可以帮助我们为程序选择正确的设计，并使用可读性更强的语法来实现它。当我们需要让客户端代码或最终用户从同一接口的多个实现中进行选择时，就应使用策略模式或其顶级函数的实现。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"https://dc1y.github.io/tags/策略模式/"}]},{"title":"【Python 与模式】观察者模式","slug":"python-observer-pattern","date":"2018-03-31T03:32:28.000Z","updated":"2018-03-31T03:32:28.000Z","comments":true,"path":"python-observer-pattern/","link":"","permalink":"https://dc1y.github.io/python-observer-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 观察者模式对于状态监测及事件处理等情况非常有用。这种模式允许一个对象被一组未知的、动态的 “观察者” 对象监测。 当核心对象的一个值发生改变时，它将通过调用 update() 方法来通知所有观察者对象变化已经发生。每个观察者则负责在核心对象变化时执行不同的任务；核心对象并不知道、也不关心这些任务是什么，而观察者通常也不知道或关心其它观察者在做什么。 下面是观察者模式的 UML 图：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 观察者模式对于状态监测及事件处理等情况非常有用。这种模式允许一个对象被一组未知的、动态的 “观察者” 对象监测。 当核心对象的一个值发生改变时，它将通过调用 update() 方法来通知所有观察者对象变化已经发生。每个观察者则负责在核心对象变化时执行不同的任务；核心对象并不知道、也不关心这些任务是什么，而观察者通常也不知道或关心其它观察者在做什么。 下面是观察者模式的 UML 图： 观察者的示例观察者模式在冗余备份系统中非常有用。我们可以编写一个核心对象来维护某些值，然后让一个或多个观察者创建该对象的序列化拷贝。这些拷贝可能存储在数据库、远程主机或本地文件中。让我们使用属性来实现这个核心对象： class Inventory: def __init__(self): self.observers = [] self._product = None self._quantity = 0 def attach(self, observer): self.observers.append(observer) @property def product(self): return self._product @product.setter def product(self, value): self._product = value self._update_observers() @property def quantity(self): return self._quantity @quantity.setter def quantity(self, value): self._quantity = value self._update_observers() def _update_observers(self): for observer in self.observers: observer() 这个对象有两个属性，当设置属性值时，将调用其自身的 _update_observers 方法。该方法所做的，就是遍历可用的观察者、并让每个观察者得知有些东西改变了。在这个例子中，我们直接调用了观察者对象；观察者对象必须实现 __call__ 来处理更新。这在许多面向对象的编程语言中是行不通的，但在 Python 中，这是增强代码可读性的有用捷径。 现在，让我们实现一个简单的观察者对象；该对象仅仅是把一些状态打印到控制台上： class ConsoleObserver: def __init__(self, inventory): self.inventory = inventory def __call__(self): print(self.inventory.product) print(self.inventory.quantity) 这里没啥特别让人惊喜的；被观察的对象在初始化器中传入，随后调用了观察者，做了 “一些事情”。我们可在交互式控制台中测试这个观察者： &gt;&gt;&gt; i = Inventory()&gt;&gt;&gt; c = ConsoleObserver(i)&gt;&gt;&gt; i.attach(c)&gt;&gt;&gt; i.product = \"Widget\"Widget0&gt;&gt;&gt; i.quantity = 5Widget5 把观察者附加（attach）到存货对象后，每次我们改变两个被观察的属性中的任何一个时，观察者就会被调用，并且其动作得以执行。甚至，我们还可以添加两个不同的观察者实例： &gt;&gt;&gt; i = Inventory()&gt;&gt;&gt; c1 = ConsoleObserver(i)&gt;&gt;&gt; c2 = ConsoleObserver(i)&gt;&gt;&gt; i.attach(c1)&gt;&gt;&gt; i.attach(c2)&gt;&gt;&gt; i.product = \"Gadget\"Gadget0Gadget0 现在，当我们改变产品时，出现两组输出，每个观察者一组。这里的关键在于，我们可以轻易添加完全不同类型的观察者，用于把数据同时备份到文件、数据库或 Internet 应用中。 观察者模式把被观察的代码，从执行观察的代码中分离出来。如果不使用这种模式，则我们将不得不把代码放入到每个属性中，以便处理各种可能的情况；在控制台显示日志、更新数据库或文件，等等。这些任务各自的代码，将全部混杂到被观察的对象中。维持这样的对象将是一场噩梦，并且日后添加新的监测功能也将极其痛苦。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://dc1y.github.io/tags/观察者模式/"}]},{"title":"【python与模式】装饰器模式","slug":"python-decorator-pattern","date":"2018-03-30T16:04:24.000Z","updated":"2018-03-30T16:04:24.000Z","comments":true,"path":"python-decorator-pattern/","link":"","permalink":"https://dc1y.github.io/python-decorator-pattern/","excerpt":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 装饰器模式允许我们把提供核心功能的对象，“包裹”在改变这个功能的其它对象中。任何对象与这个经过装饰的对象交互时，可采用完全相同的方式，就像该对象并未经过装饰时一样（即，经过装饰的对象，具有与核心对象完全相同的接口）。 装饰器模式有两种主要用途： 改进某个组件向另一个组件发送数据时的响应 支持多种可选行为 第二种用途通常是多重继承的合理替代方案。我们可以构建一个核心对象，然后围绕它创建装饰器。由于装饰器对象具有与核心对象相同的接口，我们甚至还可以把它再包裹到另一个装饰器中。下面是装饰器的UML图：","text":"提示：本文译自《Python 3 Object-oriented Programming, Second Edition》，Chapter 10: Python Design Patterns I。 装饰器模式允许我们把提供核心功能的对象，“包裹”在改变这个功能的其它对象中。任何对象与这个经过装饰的对象交互时，可采用完全相同的方式，就像该对象并未经过装饰时一样（即，经过装饰的对象，具有与核心对象完全相同的接口）。 装饰器模式有两种主要用途： 改进某个组件向另一个组件发送数据时的响应 支持多种可选行为 第二种用途通常是多重继承的合理替代方案。我们可以构建一个核心对象，然后围绕它创建装饰器。由于装饰器对象具有与核心对象相同的接口，我们甚至还可以把它再包裹到另一个装饰器中。下面是装饰器的UML图： 图中，Core及全部装饰器都实现了Interface。装饰器通过组合的方式，维护着一个指向Interface实例的引用。当被调用时，装饰器在调用它所包裹接口的之前或之后，执行额外的操作。被包裹的对象可以是另一个装饰器，也可以是核心功能。尽管多个装饰器可以彼此包裹，但处于所有装饰器“中心”的对象提供了核心功能。 装饰器示例让我们来看看一个使用TCP socket进行网络编程的例子。socket.send()接收一串输入字节，并将其输出到接收端的socket。有许多库采用了socket，并调用这个函数来发送数据流。让我们创建这样一个交互式shell，它等待来自客户端的连接，然后提示用户输入一个字符串作为响应： import socketdef respond(client): response = input(\"Enter a value: \") client.send(bytes(response, 'utf=8')) client.close()server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind(('localhost', 2401))server.listen(1)try: while True: client, addr = server.accept() respond(client)finally: server.close() respond函数接受一个socket参数，并提示用户输入作为应答的数据，然后发送该数据。为使用这个函数，我们构建了一个服务器socket，并让其监听本地计算机的2401端口（可随意选择）。当某个客户端建立了连接时，将调用respond函数，该函数在交互式地请求应答数据后，作出相应的响应。需要注意的重点是，respond函数只关注socket接口的两个方法：send和close。要测试这个对象，可编写一个简单的客户端，来连接到同一个端口，并在输出来自服务器的响应后退出： import socketclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect(('localhost, 2401))print(\"Received: &#123;0&#125;\".format(client.recv(1024)))client.close() 使用这两个程序的步骤如下： 在一个终端中启动服务器。 打开另一个终端窗口，并运行客户端。 在服务器窗口的 Enter a value: 提示中，键入一个值并回车。 客户端将接收到你键入的内容，将其打印在控制台后退出。再一次运行客户端；服务器将再一次提示输入响应值。 现在再看看服务器代码，这些代码有两个部分。respond函数把数据发送给一个socket对象。其余的脚本则负责创建这个socket对象。我们将创建两个装饰器，来自定义socket的行为，而不必扩展或修改socket本身。 让我们先从“logging”装饰器开始。这个对象将把要发送的数据先输出到服务器控制台，然后再发送给客户端： class LogSocket: def __init__(self, socket): self.socket = socket def send(self, data): print(\"Sending &#123;0&#125; to &#123;1&#125;\".format(data, self.socket.getpeername()[0])) self.socket.send(data) def close(self): self.socket.close() 这个类装饰了一个socket对象，并向客户端socket提供了send和close接口。更完整的装饰器，应该同时实现（并且可能自定义）其余的socket方法。同时也应正确地实现send的所有参数（实际上该方法接受一个可选的标志参数），但是，我们想让示例保持简单！每次调用该对象的send方法时，它将把输出记录到屏幕，然后再使用原来的socket向客户端发送数据。 要使用这个装饰器，我们只需修改一行代码。把调用respond时传入的socket，改为传入经过装饰的socket： respond(LogSocket(client)) 尽管非常简单，但我们为何不扩展socket类并重写send方法呢？我们可以在进行日志记录后，再调用super().send来执行实际的发送。这个设计也没错。 当面对装饰器和继承的选择时，若需根据某些条件动态地修改对象，则只能选择装饰器。例如，我们可能只想在服务器处于调试模式时，才启用日志装饰器。当有多于一种的可选行为时，装饰器也优胜于多重继承。作为示例，我们可编写另一个装饰器，以便在调用send时使用gzip来压缩数据： import gzipfrom io import BytesIOclass GzipSocket: def __init__(self, socket): self.socket = socket def send(self, data): buf = BytesIO() zipfile = gzip.GzipFile(fileobj=buf, mode=\"w\") zipfile.write(data) zipfile.close() self.socket.send(buf.getvalue()) def close(self): self.socket.close() 这个版本的send方法在把数据发送给客户端之前，先对数据进行压缩。 现在我们有了两个装饰器，我们可以编写代码，以便在响应时动态地切换装饰器。下面的示例并不完整，但演示了混搭装饰器应遵循的逻辑： client, addr = server.accept()if log_send: client = LoggingSocket(client)if client.getpeername()[0] in compress_hosts: client = GzipSocket(client)respond(client) 这段代码检查一个假想的、名为log_send的配置变量。若该变量启用，则把socket包裹在LoggingSocket中。同样，代码检查已连接的客户端是否存在于可接受压缩内容的地址列表中。若是，则把client再进一步包裹到GzipSocket装饰器中。注意根据配置和已连接客户端的情况，这两个装饰器可能全不或全部启用、或者是只启用其中一个。尝试用多重继承来编写这个例子，并看看结果有多乱！ Python中的装饰器装饰器模式在Python中很有用，但有其它做法。例如，我们可以使用猴子补丁（monkey-patching）来得到类似的效果，见第7章的相关讨论。单重继承也是一种选择，其中“可选”的计算在一个较大的方法中执行；而多重继承，也不能仅仅只为不适合于刚才的例子而完全否决。 在Python中，在函数上应用这种模式相当常用。我们在前一章了解到，函数也是对象。实际上，函数的装饰是如此常见，以至于Python提供了一种特殊的语法，来方便对函数应用装饰器。 例如，我们可以用更普遍的观点来观察日志的示例。除在调用socket的发送时记录日志外，记录对某些函数或方法的所有调用的日志可能也很有用。下面的示例实现了执行这个功能的装饰器： import timedef log_calls(func): def wrapper(*args, **kwargs): now = time.time() print(\"Calling &#123;0&#125; with &#123;1&#125; and &#123;2&#125;\".format(func.__name__, args, kwargs)) return_value = func(*args, **kwargs) print(\"Executed &#123;0&#125; in &#123;1&#125;ms\".format(func.__name__, time.time() - now)) return return_value return wrapper def test1(a, b, c): print(\"\\ttest1 called\") def test2(a, b): print(\"\\ttest2 called\") def test3(a, b): print(\"\\ttest3 called\") time.sleep(1) test1 = log_calls(test1) test2 = log_calls(test2) test3 = log_calls(test3) test1(1, 2, 3) test2(4, b=5) test3(6, 7) 这个装饰器函数非常类似于我们前面探索的示例；在前面的例子中，装饰器接受一个类socket对象，并创建另一个类socket对象。在这里，我们的装饰器接受一个函数对象，并返回一个新的函数对象。这段代码由三个独立的任务组成： 一个log_calls函数，它接受另一个函数 这个函数（在内部）定义了一个名为wrapper的新函数，wrapper在调用传入的函数之前（及之后）执行了一些额外的操作 返回这个新函数 三个test*函数演示了装饰器的用法。test3包含了sleep调用来演示定时测试。我们把每一个函数传入到装饰器中，这个装饰器返回一个新函数。我们把这个新函数赋值给原来的变量名，实际上是用装饰过的函数替换掉了原来的函数。 这种语法允许我们动态地建立经过装饰的函数对象，与装饰socket的示例一样；如果不替换变量名，我们甚至可以保留装饰过和未装饰的版本，以便在不同的情况下使用。 这些装饰器所带来的修改，通常永久性地应用到各个函数上。在这种情况下，Python支持用一种特殊的语法，来在定义函数时应用装饰器。我们已在讨论property装饰器时看到这种语法；现在，让我们看看它的工作方式。 与在定义方法之后再应用装饰器函数不同，我们可以使用@decorator语法来一次性完成装饰： @log_callsdef test1(a, b, c): print(\"\\ttest1 called\") 这种语法的首要优点时，是我们可以在函数定义的同时，就看到它被装饰了。若在后面再应用装饰器，阅读代码的人，可能会没看到函数已被完全改变了。回答诸如这样的问题，“为什么我的程序日志函数调用了控制台？”，可能会变得非常困难！不过，这种语法只能应用到我们定义的函数，因为我们无法访问其它模块的源代码。如果需要装饰第三方库的函数，则必须使用前面的语法。 除刚才看到的语法之外，还有更多的装饰器语法。在这里，我们没有足够的篇幅来探讨这个高级主题，因此，请查阅Python参考手册或其它教程，以获得更多信息。装饰器也可创建可调用对象，而不仅仅是返回函数的函数。类也可以被装饰；此时，装饰器返回一个新类，而不是一个新函数。最后，装饰器可以接受参数，并在逐个函数的基础上进行定制。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"},{"name":"设计模式","slug":"python/设计模式","permalink":"https://dc1y.github.io/categories/python/设计模式/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://dc1y.github.io/tags/设计模式/"},{"name":"装饰器模式","slug":"装饰器模式","permalink":"https://dc1y.github.io/tags/装饰器模式/"}]},{"title":"pywinauto，自动化你的 Windows GUI","slug":"pywinauto-auto-your-gui","date":"2018-03-27T07:38:47.000Z","updated":"2018-03-27T07:38:47.000Z","comments":true,"path":"pywinauto-auto-your-gui/","link":"","permalink":"https://dc1y.github.io/pywinauto-auto-your-gui/","excerpt":"pywinauto 是一组 python 模块，可连接到指定 Windows 应用的进程，并通过向应用的窗口对话框和控件发送动作，来实现图形界面（GUI）的操作自动化。 在 pywinauto 出现之前，Python 社区中已存在若干 GUI 自动化工具，如 PyAutoGui、pyautoit、autopy 等。这些工具或基于图像识别或仅适用于较旧的 Win32 API，使用上的灵活性、准确度和效率上有一定的限制。相比之下，pywinauto 采用了面向对象的方式，并且只采用可读性较高的 Python 代码，不必另外再学习专用的脚本语言。 本文基于 Windows 10 x64 中文环境，内容涉及 pywinauto 的安装，同时也以记事本的自动化操作为例，揭示了 pywinauto 的基本功能和概念。","text":"pywinauto 是一组 python 模块，可连接到指定 Windows 应用的进程，并通过向应用的窗口对话框和控件发送动作，来实现图形界面（GUI）的操作自动化。 在 pywinauto 出现之前，Python 社区中已存在若干 GUI 自动化工具，如 PyAutoGui、pyautoit、autopy 等。这些工具或基于图像识别或仅适用于较旧的 Win32 API，使用上的灵活性、准确度和效率上有一定的限制。相比之下，pywinauto 采用了面向对象的方式，并且只采用可读性较高的 Python 代码，不必另外再学习专用的脚本语言。 本文基于 Windows 10 x64 中文环境，内容涉及 pywinauto 的安装，同时也以记事本的自动化操作为例，揭示了 pywinauto 的基本功能和概念。 安装 pywinauto为避免破坏系统级上的 Python 环境，我们将使用 pipenv 创建一个项目虚拟环境，并在这个项目环境中安装 pywinauto。打开 Windows 资源管理器，进入打算存放项目的位置（例如 D:\\temp），在空白处右击并选择 “在此处打开 PowerShellp 窗口”，然后运行如下命令： PS D:\\temp&gt; cmdD:\\temp&gt;mkdir test_pywaD:\\temp&gt;cd test_pywaD:\\temp\\test_pywa&gt;pipenv install pywinautoCreating a Pipfile for this project…Installing pywinauto…...To activate this project's virtualenv, run the following: $ pipenv shell 提示：关于 Python 的虚拟环境和包管理，详见 pipenv，人性化的 Python 开发流程。 耐心等待，直至 pipenv 在 test_pywa 文件夹中创建项目虚拟环境，并安装好 pywinauto。接着，让我们来快速测试一下 pywinauto： D:\\temp\\test_pywa&gt;pipenv run pythonPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; from pywinauto.application import Application&gt;&gt;&gt; app = Application(backend=\"uia\").start(\"notepad.exe\")&gt;&gt;&gt; app.UntitledNotepad.type_keys(\"%FX\")...pywinauto.findbestmatch.MatchError: Could not find 'UntitledNotepad' in 'dict_keys(['无标题 - 记事本 Dialog','Dialog','无标题 - 记事本'])' 出错了！不过，我们也发现了，当运行倒数第二行代码（即 app = Application...）时，记事本打开了，这起码说明 pywinauto 的确已经起作用了。错误信息显示 pywinauto 无法在 dict_keys([&#39;无标题 - 记事本 Dialog&#39;, &#39;Dialog&#39;, &#39;无标题 - 记事本&#39;]) 中找到 UntitledNotepad，或许我们可以试着运行： &gt;&gt;&gt; app['无标题 - 记事本'].type_keys(\"%FX\")&lt;hwndwrapper.DialogWrapper - '', Notepad, 920150&gt; 记事本退出了。代码中的 type_keys 表示按键，% 相当于 Alt，type_keys(&quot;%FX&quot;) 就是按下 “Alt+F,X”，从记事本菜单中可以看到，这个组合键对应于 “文件 | 退出”。这样，记事本退出也就不奇怪了。 提示：也可以通过窗口类名来查找并退出记事本，即 app.Notepad.type_keys(&quot;%FX&quot;)。 现在，我们已安装了 pywinauto 且一切正常，可以更深入地了解 pywinauto 的更多功能了。 利用 pywinauto 进行自动化通过上面这个简单的例子，你可能已经感觉到了，pywinauto 的自动化操作与我们平常的手工操作并无不同，只不过是通过代码来实现操作而已。操作过程通常都是先进入到应用中，找到要操作的窗口、对话框和控件，然后使用鼠标和键盘执行所需的操作。 下面，我们将再一次 pywinauto 启动记事本，并在交互式 python 中一步步执行一些操作，并在这个过程中了解涉及到的 pywinauto 概念和技术细节。 入口点——连接到应用的进程照例运行 python，导入 pywinauto.application 模块，并创建该模块中的 Application 类的一个实例： pipenv run python&gt;&gt;&gt; from pywinauto.application import Application&gt;&gt;&gt; app = Application(backend='win32').start('notepad.exe') 在上面的代码中，pywinauto 在一个新的进程中启动了记事本，并用一个名为 app 的 Application 实例连接到这个记事本进程。这个 app 实例就是自动化的入口点，后续的操作均以这个 app 为基础。 对于跨进程的应用来说，例如 Windows 10 的 “计算器” 就在一个以上的进程中绘制其界面部件，则应采用 Desktop 对象作为入口点： from subprocess import Popenfrom pywinauto import DesktopPopen('calc.exe', shell=True)dlg = Desktop(backend=\"uia\").Calculatordlg.wait('visible') GUI 对象检查上面的代码使用了 backend 来为 Application 实例指定后端的访问技术。Windows 有两种访问技术： Win32 API（backend=&quot;win32&quot;）：默认的后端访问技术，适用于 MFC、VB6、简单的 WinForms 控件及大多数老旧的应用。 MS UI Automation（backend=&quot;uia&quot;）：适用于 WinForms、WPF、应用商店、Qt5、浏览器等。 提示：pywinauto 不支持 Java AWT/Swing、GTK + 及 Tkinter 等。Linux 上的 AT SPI 及 Apple Accessibility API 未来有支持计划。 如果未能确认要采用的后端访问技术，可运行 Spy++ 或 Inspect.exe 并查看目标应用。若 Spy++ 能够显示应用的所有控件，则应采用 &quot;win32&quot; 后端，否则，在 Inspect.exe 中切换到 UIA 模式，若能够显示比 Spy++ 更多的控件和属性，则可选择 &quot;uia&quot;。 提示：适用于 Windows 的 GUI 检查工具，可从 这里 免费下载。 即使检查工具无法查看到应用的部分或全部控件，仍然可以利用基本的 mouse 和 keyboard 模块，通过生成鼠标和键盘事件来控制应用。 连接到目标应用的进程创建 Application 实例后，必须将其连接到目标应用的进程。Application 提供了两个连接进程的实例方法： start(self, cmd_line, timeout=app_start_timeout)connect(self, **kwargs) start() 方法可启动目标应用，并连接到其进程，其中：cmd_line 是目标应用的路径及参数，如 r&quot;c:\\path\\to\\your\\application --arguments&quot;；timeout 参数可选，通常在应用启动时间非常长时使用。 connect() 方法则用于连接到已经启动的进程，可以向该方法传入应用的进程 ID（可在任务管理器中查看 PID）、应用的窗口句柄、可执行文件的路径，或者是各种窗口参数的任意组合。例如： # 传入 PIDapp = Application().connect(process=2341)# 传入句柄app = Application().connect(handle=0x010f0c)# 传入可执行文件路径app = Application().connect(path=r\"c:\\windows\\system32\\notepad.exe\")# 参数组合，这些参数被传递给 pywinauto.findwindows.find_elements() 函数app = Application().connect(title_re=\".*Notepad\", class_name=\"Notepad\") 注意：使用 connect() 方法时，通常需要编写一个循环来等待应用完全完成启动。 查找窗口、对话框和控件连接到目标应用后，就可以透过这个 app 实例来访问记事本的窗口、对话框和控件了。首先运行以下语句，在记事本主窗口周围绘制绿色的轮廓线，以确认 app 实例连接到正确的应用： &gt;&gt;&gt; app['无标题 - 记事本'].draw_outline() 上面的代码采用了字典索引的方式找到了记事本的主窗口，并执行了绘制轮廓线的方法。除此之外，你还可以使用 app.window() 方法来查找窗口，下面的语句同样可在记事本主窗口周围绘制轮廓线： app.window(title='无标题 - 记事本').draw_outline() 提示：在英文操作系统上，你还可以采用魔法属性来查找窗口并绘制轮廓线，例如 app.UntitledNotepad.draw_outline()。不过，由于 Python 的属性不允许含有空格或其它特殊字符，因此在中文系统上无法采用这种方式，这也是本文最初的示例出错的原因。 为方便后续操作，让我们把记事本的主窗口保存到一个变量（例如 mainwin）中： &gt;&gt;&gt; mainwin = app['无标题 - 记事本']&gt;&gt;&gt; mainwin&lt;pywinauto.application.WindowSpecification object at 0x000001AA025AD2E8&gt; 记事本主窗口是一个 WindowSpecification 对象，它是 pywinauto API 的一个核心概念。WindowSpecification 对象并非真正的窗口或控件，而是一组描述窗口或控件的条件。执行操作时，pywinauto 会根据这些条件寻找匹配的窗口或控件。例如，目前 mainwin 的匹配条件就是窗口或控件应含有 &#39;无标题 - 记事本&#39; 字样，在当前情况下对应于记事本的主窗口。若 pywinauto 无法找到与这些条件相匹配的窗口或控件，就会抛出 ElementNotFoundError。 pywinauto 在查找窗口或控件时采用了最佳匹配（best match）的方式，这意味着你不必在 WindowSpecification 中指定绝对精确的条件。例如 app[&#39;无题 - 记事本&#39;]、app[&#39;无题 - 记事&#39;] 等等，都可以匹配目前情况下的记事本的主窗口。不过，为避免混淆，确定条件时还是应该尽量精确。 执行操作掌握了查找窗口和控件的办法，就可以用代码来执行一些自动化操作了。运行如下语句： &gt;&gt;&gt; mainwin.menu_select('帮助 -&gt; 关于记事本') 上面的代码从 mainwin 的 “帮助” 菜单中选择了 “关于记事本”，打开了“关于记事本” 对话框。接着，让我们使用代码关闭这个对话框： &gt;&gt;&gt; app['关于记事本']['确定'].click() 上面的代码中，首先通过 [&#39;关于记事本&#39;] 确定要操作的窗口，然后通过 [&#39;确定&#39;] 定位到 “确定” 按钮，最后调用 click()方法模拟鼠标单击这个按钮。 注意：若上面代码未能关闭 “关于记事本” 对话框，可再重复运行一次。测试中发现，同样用代码来打开和关闭 “编辑 | 替换” 对话框，则不存在这个问题。若频繁出现这种现象，甚至需要数量不定的多次单击 “确定” 按钮，或许可考虑使用一个循环来解决问题，如下： while app['关于记事本'].visible app['关于记事本']['确定'].click() 查看控件标识符现在，让我们在记事本主窗口的编辑框中输入一些内容，继续试验 pywinauto 的更多功能。第一步显然是定位到编辑框，但这个编辑框并没有标题，如何才能让 pywinauto 找到这个窗口呢？ 一种办法是在 Spy++ 中找到并展开 “无标题 - 记事本”，右击其“Edit” 子项并选择 Highlight（如下图），可看到记事本的编辑窗口闪动数次，由此可确认 Edit 对应于记事本的编辑框。 另一种办法不需要依赖外部工具，调用 WindowSpecification 对象的 print_control_identifier() 方法，即可以树状列表的形式输出该对象所包含全部控件的标识符。例如查看记事本主窗口的所有控件： &gt;&gt;&gt; mainwin.print_control_identifiers()Control Identifiers:Notepad - '无标题 - 记事本' (L968, T148, R1798, B675)['无标题 - 记事本 Notepad', '无标题 - 记事本', 'Notepad']child_window(title=\"无标题 - 记事本\", class_name=\"Notepad\") | | Edit - '' (L976, T199, R1790, B667) | ['无标题 - 记事本 Edit', 'Edit'] | child_window(class_name=\"Edit\") | | StatusBar - '' (L976, T645, R1790, B667) | ['StatusBar', 'StatusBar 第 1 行，第 1 列', '无标题 - 记事本 StatusBar'] | child_window(class_name=\"msctls_statusbar32\") 可以看到主窗口包含编辑框和状态栏两个子窗口，同时也列出了访问这些子窗口的两种方式：字典索引和方法调用。其中的字典索引还列出了多个可选项，任选其一即可： &gt;&gt;&gt; # 若采用不含非英文字符的字典索引，则可直接以属性的方式来访问，如下：&gt;&gt;&gt; mainwin.Edit.type_keys(\"自动化输入第一行\", with_spaces = True)&gt;&gt;&gt; # 也可调用 child_window() 来得到编辑框&gt;&gt;&gt; mainwin.child_window(class_name=\"Edit\").type_keys(\"&#123;ENTER&#125; 自动化输入第二行\", with_spaces = True) 上面的代码调用了编辑框的 type_keys() 方法，向编辑框中输入指定的内容，其中 with_spaces 为 True，表示保留输入内容中的空格。 现在，我们已经完成了重要信息的输入，可以保存文件并关闭记事本，然后关闭 python 了： &gt;&gt;&gt; mainwin.menu_select（'文件 -&gt; 保存')&gt;&gt;&gt; app['另存为']['文件名 Edit'].set_text(r'D:\\temp\\test_pywa\\pywa.txt')&gt;&gt;&gt; app['另存为']['保存 Button'].click()&gt;&gt;&gt; # mainwin.type_keys('%FX') # 主窗口标题已经不是 “无标题 - 记事本” 了！&gt;&gt;&gt; app['pywa.txt - 记事本'].type_keys('%FX')&gt;&gt;&gt; quit() 上面的代码使用了 “标题 + 类名” 的方式来访问控件，可以最大限度减少歧义并避免访问到错误的控件。当然，若因此而导致控件索引过长，也可以适当精简，pywinauto 的 “最佳匹配” 大多数情况下都能够正确处理。 此外，代码中使用了 set_text() 方法来直接设置 “文件名” 编辑框的内容。这里也完全可以采用 type_keys() 方法，但这个方法对于禁用的编辑框是无效的，与手动操作时无法在禁用的编辑框中输入是一致的。 最后，在退出记事本时，注意此时标题已经从 “无标题 - 记事本” 变成了“pywa.txt - 记事本”，要引用记事本的主窗口，必须采用 app[&#39;pywa.txt - 记事本&#39;] 的形式。 提示：“另存为” 对话框远比比记事本主窗口复杂，其中包含有地址栏、侧边栏目录树等等，调用 print_control_identifiers() 方法将输出大量内容，在其中寻找所需的控件非常困难。在这种情况下，使用前述的 Spy++ 及其 Highlight 功能，可以更容易地确定所需控件。 在资源管理器中，双击打开 pywa.txt 查看其内容，并确认一切符合预期。 完整的自动化代码说来话长，但实际上整个导入模块、启动记事本、输入内容、保存后退出的有效代码总共只有约 10 行，如下： from pywinauto.application import Applicationapp = Application(backend='win32').start('notepad.exe')mainwin = app['无标题 - 记事本']mainwin.Edit.type_keys(\"自动化输入第一行\", with_spaces = True)mainwin.child_window(class_name=\"Edit\").type_keys(\"&#123;ENTER&#125; 自动化输入第二行\", with_spaces = True)mainwin.menu_select（'文件 -&gt; 保存')app['另存为']['文件名 Edit'].set_text(r'D:\\temp\\test_pywa\\pywa.txt')app['另存为']['保存 Button'].click()app['pywa.txt - 记事本'].type_keys('%FX') 将上述代码保存到 pywa.py 文件中，然后用 pipenv run python pywa.py 运行这个脚本。可以观察到记事本以极快的速度自动打开，输入内容后保存文件，最后退出。 其它自动化相关因素GUI 构建通常需要执行大量的代码，并耗费一定的时间。也就是说，在执行 python 代码时，GUI 界面可能尚未完全生成并显示。pywinauto 有内置的默认超时，能够自动等待 GUI 的生成，而无须显式调用 sleep 或编写 while 循环。 如果有某些操作需要耗费大量时间，随后才能显示或关闭某个窗口，或者是激活某个控件，则可考虑使用 WindowSpecification 对象的 wait()或 wait_not()方法。例如，假设在执行长时间的数据转换完成，应用会弹出 “转换完成” 窗口，要等待该窗口出现并单击其 “确定” 按钮将其关闭，可： app['转换完成'].wait('enabled')app['转换完成']['确定'].click() 此外，多线程应用经常采用延迟初始化技术，在 GUI 已经可用的情况下，可能仍有部分内容尚未初始化完成。在这种情况下，可考虑采用 Application 的 wait_cpu_usage_lower() 方法。例如： app.wait_cpu_usage_lower(threshold=5) # 等到 CPU 使用率低于 5% 尾声本文关于 pywinauto 的探讨到此为止，更多信息请参阅 官方文档。此外，pywinauto 的 GitHub 仓库 的 examples 目录中，也有大量示例可供参考。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"pywinauto","slug":"pywinauto","permalink":"https://dc1y.github.io/tags/pywinauto/"}]},{"title":"pipenv，人性化的 Python 开发流程","slug":"pipenv-dev-workflow","date":"2018-03-23T10:07:34.000Z","updated":"2018-03-23T10:07:34.000Z","comments":true,"path":"pipenv-dev-workflow/","link":"","permalink":"https://dc1y.github.io/pipenv-dev-workflow/","excerpt":"假设你已经 在系统级上安装了 Python，并受客户 A 委托开发一个网站项目，你为该项目创建了一个文件夹并开始编码，期间还安装了一些库，包括 Django 框架，其版本为 1.8.19。项目投产后反应良好，以至于客户 B 也委托你开发另一个网站，项目 B 同样需要 Django，且其最新版本为 2.3。但你不敢贸然在系统级上安装这个新版本，因为替换掉老版本后，原来的项目 A 可能会因潜在的不兼容问题而出错。这时候你有两个选择：要么继续使用旧版本，要么升级 Django 并确保项目 A 仍能正常运行。 可以肯定的是，这两种做法都无法令你满意。这时候，你就需要 虚拟环境（Virtual Environment） 了。","text":"假设你已经 在系统级上安装了 Python，并受客户 A 委托开发一个网站项目，你为该项目创建了一个文件夹并开始编码，期间还安装了一些库，包括 Django 框架，其版本为 1.8.19。项目投产后反应良好，以至于客户 B 也委托你开发另一个网站，项目 B 同样需要 Django，且其最新版本为 2.3。但你不敢贸然在系统级上安装这个新版本，因为替换掉老版本后，原来的项目 A 可能会因潜在的不兼容问题而出错。这时候你有两个选择：要么继续使用旧版本，要么升级 Django 并确保项目 A 仍能正常运行。 可以肯定的是，这两种做法都无法令你满意。这时候，你就需要 虚拟环境（Virtual Environment） 了。 虚拟环境与包管理如果你在开始项目之前，就分别为项目 A 和项目 B 创建了虚拟环境，那么，你可以自由地在项目 B 中安装 Django 2.3，而丝毫不必担心对项目 A 中现有的 Django 1.8.19 造成影响。 除上述的版本不兼容风险外，不同性质的 Python 项目可能需要安装和使用不同的第三方库，例如网站开发可能会使用 Django、Flask 等，而在进行数据分析时，又可能需要 numpy、pandas 等。如果把所有的第三方库都直接安装到系统级的 Python 环境中，势必会造成不必要的混乱和冗余。此外，若你的项目需要协作，在多个协作者之间重建完全一致的开发环境，也将面临极大的困难。更为严重的是，对于 Linux 等自带 Python 的系统来说，若其任务和操作所依赖的系统级 Python 环境被不慎破坏，甚至可能造成整个系统的崩溃。 解决上述问题的办法是，始终为每一个项目创建一个虚拟环境，并在其中只安装与项目直接相关的各种库及其依赖。每个虚拟环境就是一个独立的文件夹，可确保各项目的依赖彼此隔离，不会相互影响，同时也避免了对系统级的 Python 环境造成污染或破坏。 多年来，Python 社区在虚拟环境及包管理方面开发和积累了大量工具，如 easy_install、pip、virtualenv、virtualenvwrapper、virtualenv-burrito、autoenv、pyenv、pyvenv 等等，甚至 Python 3 还加入了一个名为 venv 的标准库。在这些工具中，最经典且广泛使用的是 pip 和 virtualenv，前者用于管理第三方包，而后者用于管理虚拟环境。 如果你对这些工具及其名称感到眼花缭乱，无所适从，别担心…… 创建于 2017 年 1 月的 pipenv 结束了 Python 虚拟环境及包管理方面的混乱局面。 pipenv 入门目前，pipenv 已成为 Python 官方推荐的包管理工具。它整合了 pip 和 virtualenv 的功能，旨在成为 Python 项目最好的依赖管理器。Pipenv 能够为你的项目自动创建和管理虚拟环境，并在你安装 / 卸载包时，在 Pipfile 中添加 / 移除相关的条目。它甚至能够生成更重要的 Pipfile.lock，从而精确再现开发环境。 与前面提到的其它虚拟环境和包管理工具相比，pipenv 更简明、更人性化。 安装 pipenv作为创建每个项目不可或缺的依赖管理器，Pipenv 几乎是安装 Python 之后的第一个必装工具。不过，为避免 pipenv 及其依赖包破坏系统级上的 Python 环境，最好在用户级上安装 pipenv。 以你的 Windows 帐户登录系统，运行如下命令来确认系统中已安装了 pip，然后使用 --user 参数来在用户级上安装 pipenv： C:\\Users\\username&gt;pip --versionpip 9.0.1 from c:\\program files\\python36\\lib\\site-packages (python 3.6)C:\\Users\\username&gt;pip install --user pipenv 安装完成后，尝试运行如下命令查看 pipenv 的版本号： C:\\Users\\username&gt;pipenv --version'pipenv' 不是内部或外部命令，也不是可运行的程序或批处理文件。 刚刚安装的 pipenv 居然无法使用？原来，执行用户级安装时，pipenv 将被安装到 C:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\Scripts 中。要想能够直接运行 pipenv，必须将这个路径添加到用户的环境变量中。 提示：运行如下命令，可查看用户级的包路径，将最后的 site-packages 替换为 Scripps，就是用户级可执行文件（包括 pipenv）的安装位置： C:\\Users\\username&gt;py -m site --user-siteC:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\site-packages 进入 “控制面板 | 用户帐户 | 用户帐户”，单击左侧的 “更改我的环境变量”（如下图），打开当前用户的“环境变量” 对话框，在上方的用户变量列表中选择 Path 并单击 “编辑…”，添加 C:\\Users\\username\\AppData\\Roaming\\Python\\Python36\\Scripts 后，依次点击各对话框的“确定” 来确认修改： 提示：在开始菜单中搜索 “环境变量”，并单击找到的 “编辑帐户的环境变量”，可以快速打开当前用户的 “环境变量” 对话框。 重新启动命令提示符，再次查看 pipenv 的版本，可发现刚刚设置的用户环境变量已经生效： C:\\Users\\username&gt;pipenv --versionpipenv, version 11.8.3 pipenv 的基本操作使用传统的 pip 和 virtualenv，项目的虚拟环境及包管理通常涉及若干步骤：创建虚拟环境、激活虚拟环境、安装项目所需的包、禁用虚拟环境等等。并且，在项目开发过程中，还需要时不时手工维护 requirements.txt。整个过程相当繁琐，除非始终保持警惕和耐心，否则非常容易出错。 相比之下，pipenv 的虚拟环境及包管理则非常简单，大大缓解了虚拟环境及包管理的脑力消耗。 初始化项目创建并进入名为 myproj 的项目文件夹，运行 pipenv install 即可初始化项目环境（如下图）： 提示 ：在 Windows 10 中，要在指定路径快速打开 “命令提示符”，可在资源管理器中打开该路径，Shift + 右击任意空白位置，并从弹出的菜单中选择 “在此处打开 PowerShell 窗口”，然后在 PowerShell 中运行 cmd 命令。 初始化项目时，pipenv 在当前用户目录的 .virtualenvs 中创建了一个虚拟环境（上图①），并在项目文件夹中生成 Pipfile 文件和 Pipfile.lock 文件（上图②），然后锁定项目依赖并更新 Pipfile.lock，再按该文件的内容安装依赖——当然，目前项目的依赖数量为 0。 从命令输出中可以看到，虚拟环境中包含系统级 python.exe 的副本，并且也安装了 setuptools、pip、wheel 等工具，构成了一个完整的、独立于系统级的 Python 运行环境。运行如下命令，可查看项目虚拟环境的路径，并确认当前采用的 python.exe 来自于这个虚拟环境： D:\\temp\\myproj&gt;pipenv --venvC:\\Users\\dc1y\\.virtualenvs\\myproj-rd7BNkmTD:\\temp\\myproj&gt;pipenv --pyC:\\Users\\dc1y\\.virtualenvs\\myproj-rd7BNkmT\\Scripts\\python.exe Pipfile 及相应的 Pipfile.lock 文件用于跟踪管理项目的依赖信息，可取代并且优于传统的 requirements.txt。Pipfile 定义了项目的具体要求，包括从何处获取依赖包，对直接依赖包进行分组等内容。项目环境的细节则存储在 Pipfile.lock 中，包括所有的第三方包及其递归依赖包的确定版本号及其它信息，可用于精确再现项目环境。Pipfile.lock 通过 pipenv lock 命令自动生成，不必也不可手工创建和修改。 由于项目当前没有任何依赖，因此 Pipfile 和 Pipfile.lock 文件中只有一些骨架代码。 提示：Pipfile 和 Pipfile.lock 均应纳入到项目的版本管理中。 安装项目依赖包安装依赖包的命令与初始化项目的命令是一样的，只不过加上了要安装的包而已。实际上，你可以跳过初始化项目阶段，直接采用如下命令来在一个步骤中初始化项目、同时安装指定的包： D:\\temp\\myproj&gt;pipenv install requestsInstalling requests…...Adding requests to Pipfile's [packages]…Pipfile.lock (48ca4e) out of date, updating to (18fa8f)…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (18fa8f)!Installing dependencies from Pipfile.lock (18fa8f)… ================================ 8/8 - 00:00:03To activate this project's virtualenv, run the following: $ pipenv shell 无需专门激活虚拟环境，只需一个命令即可安装指定的包，同时更新 Pipfile 和 Pipfile.lock 文件。默认时，pipenv 将安装指定包的当前版本，若需指定具体版本，可包名后面加上版本号，例如：pipenv install requests==&#39;2.18.4&#39;。 除项目产品所需的包外，项目开发环境中通常还会用到其它包，如单元测试的 pytest、nose 等，但产品环境并不需要它们。为区分这种类型的包，可在运行安装命令时加入 --dev 选项： D:\\temp\\myproj&gt;pipenv install --dev pytestInstalling pytest…Collecting pytest Downloading pytest-3.5.0-py2.py3-none-any.whl (194kB)...Successfully installed attrs-17.4.0 colorama-0.3.9 more-itertools-4.1.0 pluggy-0.6.0 py-1.5.3 pytest-3.5.0Adding pytest to Pipfile's [dev-packages]…Pipfile.lock (85daf0) out of date, updating to (48ca4e)…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (48ca4e)!Installing dependencies from Pipfile.lock (48ca4e)… ================================ 10/10 - 00:00:04To activate this project's virtualenv, run the following: $ pipenv shell 从命令输出中可以看到，pytest 及其依赖已被安装到项目环境中。同时，在 Pipfile 文件的 [dev-packages] 部分添加了 pytest，并更新了 Pipfile.lock 文件的 &quot;develop&quot; 部分。 使用已安装的包现在，编写一个简单的 main.py，在其中导入并使用刚刚安装的 requests： import requestsresponse = requests.get('https://httpbin.org/ip')print('Your IP is &#123;0&#125;'.format(response.json()['origin'])) 然后，使用 pipenv run 命令来运行这个脚本，该命令将自动激活虚拟环境： D:\\temp\\myproj&gt;pipenv run python main.pyYour IP is 8.8.8.8 你也可以先激活虚拟环境，再直接使用 python 来运行脚本（exit 可退出虚拟环境）： D:\\temp\\myproj&gt;pipenv shellLaunching subshell in virtual environment. Type 'exit' to return.Microsoft Windows [版本 10.0.16299.309](c) 2017 Microsoft Corporation。保留所有权利。D:\\temp\\myproj&gt;python main.pyYour IP is 8.8.8.8D:\\temp\\myproj&gt;exitD:\\temp\\myproj&gt; pipenv 的其它操作如果希望把虚拟环境放在项目文件夹内，可在当前用户的 “环境变量” 对话框中，增加一个名为 PIPENV_VENV_IN_PROJECT 的用户变量，并将其值设置为 1（如下图）。 重启 “命令提示符” 后，运行如下命令，先移除用户目录中的现有虚拟环境，再在项目的. venv 目录中重建项目虚拟环境： D:\\temp\\myproj&gt; pipenv --rmRemoving virtualenv (C:\\Users\\username\\.virtualenvs\\myproj-rd7BNkmT)…D:\\temp\\myproj&gt;pipenv installCreating a virtualenv for this project…...Virtualenv location: D:\\temp\\myproj\\.venvInstalling dependencies from Pipfile.lock (7b8df8)… ================================ 5/5 - 00:00:04To activate this project's virtualenv, run the following: $ pipenv shell 提示 ：如果需要重建项目开发环境，则加上 --dev 选项，即 pipenv install --dev。 此外，卸载不再需要的包可使用 pipenv uninstall 命令，更新包可使用 pipenv update 命令，显示依赖图可使用 pipenv graph 命令，等等。更多的命令和选项，请参阅 pipenv 官方文档。 尾声pipenv 确实简化了 Python 项目的虚拟环境和包管理。掌握了 pipenv，或许可在今后的项目节省你的时间，并减轻你的痛苦。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"},{"name":"pipenv","slug":"pipenv","permalink":"https://dc1y.github.io/tags/pipenv/"}]},{"title":"在 Windows 上安装系统级的 Python","slug":"python-global-installation","date":"2018-03-22T08:09:11.000Z","updated":"2018-03-22T08:09:11.000Z","comments":true,"path":"python-global-installation/","link":"","permalink":"https://dc1y.github.io/python-global-installation/","excerpt":"提示：Python 核心团队已计划在 2020 年 1 月 1 日正式停止支持 Python 2，除非确实需要，否则应尽早安装并迁移到 Python 3。 在 Windows 中，Python 的安装似乎非常简单，按大多数教程的说法，只需从 Python.org 下载适合你的操作系统的安装程序，然后运行这个安装程序，在安装界面上启用 Add Python 3.6 to PATH，再单击 Install Now，即可完成安装： 不过，这种 “简单” 的安装方式，实质上是在用户级别上安装 Python，最终的安装位置位于当前用户目录下（如 C:\\Users\\&lt;username>\\AppData\\Local\\Programs\\Python\\Python36\\），其结果是只有当前用户能够使用 Python。一旦你以其它用户登录 Windows，运行 python 命令将出现如下错误提示： &apos;python&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。","text":"提示：Python 核心团队已计划在 2020 年 1 月 1 日正式停止支持 Python 2，除非确实需要，否则应尽早安装并迁移到 Python 3。 在 Windows 中，Python 的安装似乎非常简单，按大多数教程的说法，只需从 Python.org 下载适合你的操作系统的安装程序，然后运行这个安装程序，在安装界面上启用 Add Python 3.6 to PATH，再单击 Install Now，即可完成安装： 不过，这种 “简单” 的安装方式，实质上是在用户级别上安装 Python，最终的安装位置位于当前用户目录下（如 C:\\Users\\&lt;username>\\AppData\\Local\\Programs\\Python\\Python36\\），其结果是只有当前用户能够使用 Python。一旦你以其它用户登录 Windows，运行 python 命令将出现如下错误提示： &apos;python&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。 要在系统级上安装可供所有 Windows 帐户使用的 Python，必须采用自定义的安装方式。下面是在 Windows 10 64-bit 平台上安装系统级 Python 的步骤： 以管理员帐户登录 Windows，运行 Python 安装程序，并选择 Customize installation： 保持 Optional Feature 的默认选择，并单击 Next： 在 Advanced Options 中，启用 Install for all users 及 Add Python to environment variables，然后单击 Install 开始安装： 安装完成后，在管理员和非管理员用户中，运行 “命令提示符” ，并输入如下命令查看刚刚安装的 Python 的版本号。一切顺利的话，你就可以在多个 Windows 用户中使用 Python 了： C:\\Users\\&lt;username&gt;python --versionPython 3.6.4 提示：如果你打算执行全新的安装，则应在卸载 Python 后，再删除原来的安装目录及其中可能遗留的包。 安装好 Python 后，在开始任何项目之前，你还必须全面了解 Python 的虚拟环境和包管理的概念，并掌握相关工具的使用，详见《pipenv，人性化的 Python 开发流程》》。","categories":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dc1y.github.io/tags/python/"}]},{"title":"VS Code，打造沉浸式 Hexo 写作环境","slug":"blogging-in-hexo-with-vscode","date":"2018-03-13T13:58:54.000Z","updated":"2018-03-16T08:05:11.364Z","comments":true,"path":"blogging-in-hexo-with-vscode/","link":"","permalink":"https://dc1y.github.io/blogging-in-hexo-with-vscode/","excerpt":"在 《Hexo 你的专属博客》 一文中，你了解到了如何搭建 Hexo 博客站点并部署到远程仓库，实现了博文源码及站点配置的备份，并且还探讨了如何在多个设备上同步博客站点。 本文主要包括两方面的内容，首先是了解 Hexo 中与写作的相关事项和概念，其次是介绍如何利用 Visual Studio Code 来打造一个专注无干扰的 Markdown 写作环境。读完本文，你就可以做到心无挂碍、高效流畅地撰写你的博文了。","text":"在 《Hexo 你的专属博客》 一文中，你了解到了如何搭建 Hexo 博客站点并部署到远程仓库，实现了博文源码及站点配置的备份，并且还探讨了如何在多个设备上同步博客站点。 本文主要包括两方面的内容，首先是了解 Hexo 中与写作的相关事项和概念，其次是介绍如何利用 Visual Studio Code 来打造一个专注无干扰的 Markdown 写作环境。读完本文，你就可以做到心无挂碍、高效流畅地撰写你的博文了。 Hexo 的常规写作方式现在，先来了解一下 Hexo 的常规写作方式，顺便了解 Hexo 的一些非常重要的概念。 按 Hexo 官方文档 的说明，创建新博文的命令如下： $ hexo new [layout] &lt;title&gt; 运行这个命令，即可为新博文创建一个 Markdown（.md）文件。并且，若此时启动 Hexo 本地服务器，也可看到博文已经添加到站点中了。这个命令有两个选项： layout：为新博文指定布局，未指定时默认采用 post 布局。其余两个布局选项分别是 draft 和 page。 title：指定新博文的文件名，同时也是新博文在页面上最初显示的标题。若指定的标题中包含空格，则必须包围在一对半角双引号中（建议总是加上双引号，省心）。标题也可以是中文，不过英文的文件名兼容性更好。此外，Hexo 会自动将文件名中的下划线（_）自动更改为连字符（-）。 关于 Hexo 的布局所谓的 布局（layout），就是博文最终呈现出来的外观排版。如下图所示，你在每篇博文中输入的内容，将被 “嵌入” 到最终页面的 “正文” 位置。而正文之外的其它内容，如页眉、页脚及边栏等，则由 Hexo 根据你指定的布局及站点主题自动生成。 某种布局最终呈现出来的版面外观效果，由当前主题的 layout 文件夹中的同名 .ejs 文件定义。在生成最终的静态页面时，Hexo 会自动把每一篇博文 “嵌入” 到相应的 .ejs 布局中——_posts 中的博文嵌入 post.ejs 布局，_drafts 中的博文嵌入 draft.ejs 布局，而 page 博文则采用了 page.ejs 布局。 当然，最终的版面效果取决于你使用的主题。不同的主题定义了不同内容的 .ejs 文件集，而你的博文，总是 “一如既往” 地嵌入到相应的布局中的某个位置。这，也是你能够随心所欲地切换站点主题的原因。 作为测试，运行 hexo n &quot;test&quot; 命令创建一篇博文，观察 Hexo 自动在 source\\_post 文件夹中生成名为 test.md 的文件。启动 Hexo 服务器并在浏览器中查看本地站点和博文，观察并体会博文与其它布局元素之间的关系。 关于 Hexo 的模板在你的编辑器中打开刚刚生成的 test.md 文件，可发现文件中已包含如下内容： ---title: testdate: 2018-03-07 14:45:03tags:--- 两个 --- 及它们之间的内容，就是所谓的 front matter，用于保存关于博文的元数据。除博文标题及创建时间外，还可以在这里指定博文的标签、类别、关键字等等。完整的 front matter 参数及用途，请参阅 Hexo 文档。 这些 front matter 源自于 Hexo 的模板。在创建博文时，Hexo 将根据你指定的 layout，自动对博文应用 scaffolds 文件夹中的相应模板。由于刚才创建博文时采用了默认的 post 布局，因此 Hexo 将自动套用 scaffolds\\post.md 模板来生成 test.md。 在编辑器中打开 scaffolds\\post.md 模板，可发现其中包含与 test.md 中对应的 front matter。当然，双花括号之间的 title 和 date，已被自动替换为新博文的标题和创建时间： ---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags:--- Hexo 的默认模板比较简陋，你可以根据实际需要在模板中增加常用的元数据，如更新时间、类别及关键字等，以便在今后创建博文时，自动生成更完整的 front matter。例如： ---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;updated: &#123;&#123;date&#125;&#125;tags:categories:keywords:--- 回到 test.md，把 front matter 中双花括号中的 title 修改为 博文测试，并在后一个 --- 之后随便输入一些内容作为博文的正文。告一段落后，在浏览器中刷新博客站点，可发现新博文的标题和内容也随着更新了。可见，Hexo 服务器能够自动监视博文内容的改变，并且无需重启。 提示：博文的页面标题不必总是与文件名保持一致。随着你撰写越来越多的博文，你会发现现实中往往如此。即使是 Hexo 默认提供的 “Hello World” 博文，其文件名也是不一致的 “hello-world.md”。 关于标签和类别当你的博文数量越来越多的时候，你或你的读者要怎样才能快速找到想要阅读的博文呢？Hexo 通过标签和类别提供了两种归类和检索博文的方式。 标签通常是从博文内容提炼的一个或多个关键词。你可以在 front matter 的 tags: 节点中，按如下方式为每一篇博文指定一个或多个标签： # 若只有单个标签，则在同一行中指定（注意冒号后有一个空格）tags: hexo# 若需要多个标签，则以多行方式指定tags:- hexo- git 指定标签后，刷新站点页面，即可在侧边栏看到 “标签” 栏目。单击该栏目中的某个标签，将列出所有含有该标签的博文的链接；单击任一链接，即可打开并阅读相应的博文。 除标签外，你还可以从另一维度给你的博文分类。在 front matter 中增加 categories: 节点，并指定博文所属的一个或多个类别。同样，刷新站点可马上看到 “分类” 栏目： # 若只有单个类别，则在同一行中指定（注意冒号后有一个空格）categories:# 若需要多个类别，则以多行方式指定categories:- 实用工具- Hexo 需要注意的是，与多个标签并无主次之分不同，多个类别间具有层级关系。首先列出的类别为一级类别，后续列出的类别依次为其前面类别之下的子类别。以上面的多类别设置为例，页面上将把 “Hexo” 类别缩进显示在 “实用工具” 类别之下，表示 “Hexo” 是 “实用工具” 中的一个子类别。 提示：不同的主题，可能采用不同的方式来呈现类别，例如，Hueman 主题将以菜单的形式来显示类别。 关于 draft 和 page前面提到，创建新博文时，还可以选择 draft 和 page 布局。难道，除了写博文之外，你还需要写别的什么吗？ 是的。你还可以使用 draft 布局来创建草稿或不想公开发表的博文，而 page 布局则可为你的博客站点增加功能性的页面。 实际上，新建博文命令的 layout 参数也决定了新生成的博文的存放位置。采用 post 布局的博文文件将自动存放到 source\\_posts 文件夹中，draft 博文存入 source\\_drafts 文件夹，而 page 页面则直接存放在 source 文件夹中。 假设你突然产生了一个想法，但还不够成熟，也暂时没时间将其写成正式的博文，那么，你可以用 hexo n draft &quot;my-idea&quot; 来创建一篇草稿，并在其中快速且粗略地记下这个想法。当然，你也可以利用这个草稿来收集相关的资料。 提示：如果你跟我一样，希望每次新建博文都从草稿开始，则可在站点配置文件中，把 default_layout 设置为 draft。这样运行 hexo n &quot;&lt;filename&gt;&quot; 命令就将直接创建草稿，而不是正式的博文。 默认时 Hexo 不会在站点中显示草稿，也不会在远程仓库中公开发布（放心，只是没有公开发布到 master 分支而已，草稿的源码依然会备份到 src 分支）。在逐步润饰完善草稿的过程中，如果你想要预览草稿的效果，只需在启动 Hexo 服务器时加上 --drafts 参数，如 hexo s --drafts，即可让本地站点同时显示出所有草稿和博文。 最后，当你打算把草稿发布为正式的博文时，运行 hexo publish &quot;&lt;filename&gt;&quot; 命令来把把指定的草稿从 source\\_drafts 中转移到 source\\_posts 中，并自动填写发布时间。从这时候起，这篇草稿就会像普通的博文一样公开发布了。 警告：不要把站点配置中的 render_drafts 设置为 true，这将导致所有草稿也被公开发布，除非你想公开尚未完成的或隐私的博文。 至于使用 page 布局来生成功能性页面方面，给站点添加 “关于我” 的页面，就是一个很好的例子。运行如下命令来创建自我介绍页面： hexo n page \"about\" Hexo 自动在 source 文件夹中生成 about\\index.md 文件。在编辑器中打开该文件，并输入你的简介，完成后保存。然后，打开主题配置文件（例如themes\\landscape\\_config.yml），并在 menu 中添加 About: /about 菜单。如下： menu: Home: / Archives: /archives About: /about 现在，你已经掌握了 Hexo 中与博文相关的基本概念了。遵循简洁轻便低入侵性的 Markdown 语法，你可以开始 “专注无干扰” 地撰写你的博文了。 提示：Markdown 是一种轻量级的纯文本标记语言，只需输入少量标记，即可生成格式优美的印刷级排版。如果你还不了解 Markdown，可参考 Markdown 快速入门。 用 Visual Studio Code 撰写博文专注无干扰？没错，Markdown 语法本身的确简洁流畅，但在创建、编辑和预览博文的过程中，既要运行 Git Bash 并输入命令，又要在文本编辑器中一层层寻找并打开文件，还是会时不时打断写作思路的。 说得好！你已经想到了，但你还不知道，你需要使用 Visual Studio Code。 Visual Studio Code（后称 VS Code）是微软出品的一个跨平台、轻量级且功能强大的代码编辑器，原生支持 JavaScript、TypeScript 及 Node.js，并且可通过扩展（即插件）来支持 C++、C#、Java 及 Python 等几乎所有语言，当然也包括你在 Hexo 中撰写博文所使用的 Markdown 语言。VS Code 一经推出即好评如潮，是文本或代码编辑器的不二之选。 提示：访问 VS Code 官方站点 来获取更多相关信息。 近年来，各种各样的 Markdown 编辑器层出不穷，在线的离线的都有。在我们的情形中，VS Code 之所以能够脱颖而出，是因为 VS Code 在界面中集成了一个终端，默认配置为使用 Windows PowerShell。在这个集成终端中，你可以输入并执行任何命令，无论是你已渐渐熟悉的 hexo 命令、还是 git 命令，以及 Node.js 的 npm 命令，都可以信手拈来。 提示：如果你希望使用其它终端（比如 Git Bash），则可在 VS Code 中按下 F1 键打开 “命令面板”，输入 Select Default Shell 后回车，然后从清单中选择 Git Bash 即可。 有了这个多才多艺的 VS Code，你就可以进入真正 “专注无干扰” 地撰写博文的禅境了。 进入写作禅境启动 VS Code，选择 文件 | 打开文件夹 打开你的博客站点文件夹。 按下 Ctrl+` 激活 VS Code 下方的 “终端” 面板，输入 hexo n &quot;myblog&quot; 并回车。片刻之后，source\\_posts 中就生成了 myblog.md 文件。 提示：你应该已经了解到，几乎所有的 Hexo 命令都有对应的简化版本，例如 hexo n 相当于 hexo new、hexo s 相当于 hexo server 等等。关于完整的 Hexo 命令清单，请参阅 Hexo 文档。 按下 Ctrl+P 激活 VS Code 的 “快速打开” 面板，并输入刚刚创建的文件名 myblog，从弹出的清单中选择 “myblog.md source\\_posts” 并回车，VS Code 随即在编辑器窗口中打开这个文件。 接下来，想必你已经知道了，不外乎就是像平常一样修改 front matter，遵循 Markdown 规则来撰写你的博文了。 如果想预览博文，可按下 Ctrl+K, V 打开 VS Code 自带的 Markdown 预览窗口。当然了，你在这里看到的，只是博文本身内容的预览。 如果想预览整体效果，可激活终端并执行 hexo s -o，启动 Hexo 本地服务器并自动在默认浏览器中打开博客站点（这是 -o 选项的效果）。 提示：启动 Hexo 服务器后，当前的终端就被占用了。如果需要执行其它命令，同时又不想按下 Ctrl+C 来关闭 Hexo 服务器，则可按下 Ctrl+Shift+` 来打开一个新的集成终端（终端面板右上角的下拉列表，可用来在不同的终端间切换）。 你可能已经注意到了，到现在为止，你的手还没有离开过键盘！ 在 VS Code 中，一切都在你的指尖。大多数情况下，你都不用中止输入，不必腾出手来抓住鼠标到处寻找和点击——这不但影响了你的效率，也干扰了你的思路。 如果你足够细心的话，你会发现 VS Code 侧边栏的 “源代码管理” 图标上，叠加了一个带有数字的圆点。这意味着 VS Code 内置的 Git 检测到了当前站点与远程仓库之间存在未同步的内容。不过，远程仓库的管理和站点的部署，仍然必须使用 Hexo 的 deploy 命令。因为，在部署到远程仓库之前，Hexo 还执行了大量的操作，包括博文内容与布局的合成，以及生成最终的静态 HTML 文件等。 当你完成了新博文的编辑，或者是修改了站点的配置之后，就可以执行一次清理，并通过部署来发表博文和备份站点。依然是激活集成终端，然后输入并执行如下命令——你还是不用离开键盘： $ hexo cleanINFO Deleted database....$ hexo d -gINFO Start processing... 至此，你已渐渐进入撰写博文的禅境。一切纷扰离你而去，万籁俱寂之中，你正全神贯注、心无旁骛地让你的思想和见解，静静地经由你的指尖流淌出来…… 继续扫清障碍你已经能够专注无干扰地撰写博文了。不过，前行的路上，多少还有一些小障碍需要克服。在 Markdown 方面，VS Code 扩展市场中存在若干插件，适当的利用可进一步提高你的写作效率和质量。 markdownlintmarkdownlint 是一个 Markdown 语法检查器。博文中不符合 Markdown 规范的内容将被标上波浪线，并提供相应的改进提示。这个扩展可确保你的博文具有更高的兼容性（可由 Hexo 之外的其它 Markdown 解析器顺利读取），同时也可帮助你形成规范的语法习惯。 提示：按下 Ctrl+Shift+X 在侧边栏打开 “扩展” 面板，输入扩展名称即可自动执行搜索，找到所需扩展后，单击其右下角的 “安装” 按钮并耐心等待。安装完成后出现 “重新加载” 按钮，单击即可让新安装的扩展马上生效。 Markdown Shortcuts顾名思义，这个扩展为 VS Code 提供了一组插入 Markdown 标记的快捷键。尽管 Markdown 与 HTML 相比已非常简洁，但插入链接（[a hyperlink](www.example.org)）或图像（![alt text](image_url.png)）的标记仍然颇为复杂，尤其是在使用中文输入法时，时常会因忘记切换全角半角标点符号而反复犯错，极大地影响了输入的流畅性。安装此扩展后，只需： 按下 Ctrl+L，然后，若已选定了链接文本，则直接粘贴事先复制好的目标URL；否则填入链接文本后再粘贴URL。 要插入 Markdown 图像标记，可使用 Ctrl+Shift+L 快捷键。更多信息，靖参阅该扩展主页上的 “详细信息”。 提示：如果你使用 Chrome 浏览器的话，也可考虑使用名为 copy-as-markdown 的浏览器扩展，来直接从浏览器上获取 Markdown 格式的链接。 Hexo 在图像路径解析方面似乎存在问题，在 VS Code 预览中正常显示的图像，往往无法显示在远程发布后的页面上，反之亦然。一种比较简明的解决方法是：把所有图片放入 source\\imgs 文件夹中，在站点配置文件中设置 permalink: :title/，同时在博文中以 ../imgs/example.png 的形式引用图像。这样，预览和发布的博文就都可以正确显示图像了。 VS Code-pangu这是一个非常简单的插件，用于在中文和英文字符之间插入一个空格，让最终的排版结果更美观。安装 VS Code-pangu 后，只需按下 F1、输入 Why not add a space... 并回车，即可给全文或选定的内容自动插入空格。 Hexo 也有一个可以自动插入空格的插件 hexo-filter-auto-spacing，安装该插件后再在站点配置文件中设置 auto_spacing: true 即可使用。 不过，并非所有的中英文之间都适合插入空格，例如加粗的中文 **提示** ，自动插入空格后，最终的输出会变成 ** 提示 **，失去加粗效果。因此，使用 VS Code-pangu 的可控性更好，可以在编辑器中更正不适当插入的空格。 注意：如果一次性在全文中插入了空格，则应在发布前进行检查，并删除掉意外插入的不必要的空格。 Markdown Preview Enhanced改善了 VS Code 的 Markdown 预览，可显示博文目录方便导航，并支持输出 HTML、PDF、eBook 等格式。 Hexo tag snippets除标准的 Markdown 标记外，博文中也可以使用 Hexo 的 自定义标记。例如，下面的标记，可用于在博文中插入站内博文链接： &#123;% post_link slug [title] %&#125; 不过，要注意这些标签只有在 Hexo 才能正确解析，其它 Markdown 解析器很可能无法解析这些标记（实际上，VS Code 的预览就无法解析这些标记），因此应尽量慎用。 如果确实需要使用 Hexo 标记，你可以安装名为 Hexo tag snippets 的 VS Code 扩展。该扩展把 Hexo 标记定义为代码片段，只需简短的输入几个字符，就可快速输入这些标记。例如，输入 hcb 并选择 “Code Block - General (Hexo tag snippets)”，可快速插入如下的代码块标记： &#123;% codeblock title lang:language %&#125;&#123;% endcodeblock %&#125; 默认时，VS Code 并未启用 Markdown 的智能感知。要在撰写博文时使用代码片段的功能，需要添加如下用户配置： \"[markdown]\": &#123; \"editor.wordWrap\": \"on\", \"editor.quickSuggestions\": true&#125;, 提示：对于 Markdown 来说，智能感知有利有弊。若感觉你的写作受到影响，并且你的博文内容只需要少量 Hexo 标记，则不要启用该功能。 此外，你还可以在 VS Code 中定义你自己的代码片段。选择 文件 | 首选项 | 用户代码片段，打开 markdown.json 并输入如下内容，就可以使用 hxpl 和 hxrm 来快速插入站内博文链接和博文摘要的代码片段了： \"hexo post link\": &#123; \"prefix\": \"hxpl\", \"body\": [ \"&#123;% post_link $&#123;1:filename&#125; $&#123;2:title&#125; %&#125;$0\" ], \"description\": \"Link to blog article\"&#125;,\"hexo readmore\": &#123; \"prefix\": \"hxrm\", \"body\": [\"&lt;!--more--&gt;\", \"$0\"], \"description\": \"read more\"&#125; 以上内容说明，除集成终端外，VS Code 强大的扩展能力，是又一个让它完胜其它 Markdown 编辑器的特性。扩展的可能性是无穷的，并且会随着时间的推移和社区的反馈而越来越好用。甚至，有必要的话，你还可以编写你自己的扩展。 尾声经过一番跋涉，你终于达到了撰写博文的新境界。放松下来后，你可能会觉得 Hexo 的默认主题有些乏味。 如果想要以全新的面貌来呈现你的博文，可访问 Hexo 官方网站的主题页面，找到你喜欢的主题，并按其说明把主题下载（通常是使用 git clone 命令）到 themes 文件夹中；然后在站点配置文件中，把 theme: landscape 中的 landscape 修改为新主题的名称。 大多数主题在其自身文件夹中提供了 _config.yml 配置文件。利用这个主题配置文件，可以对主题的各种细节进行设置和调整。 本篇到此为止，享受你的写作吧！","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://dc1y.github.io/categories/实用工具/"},{"name":"Hexo","slug":"实用工具/Hexo","permalink":"https://dc1y.github.io/categories/实用工具/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dc1y.github.io/tags/Hexo/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://dc1y.github.io/tags/Visual-Studio-Code/"},{"name":"Markdown","slug":"Markdown","permalink":"https://dc1y.github.io/tags/Markdown/"}]},{"title":"Hexo 你的专属博客","slug":"hexo-your-blog","date":"2018-03-11T09:32:00.000Z","updated":"2018-03-17T05:41:42.838Z","comments":true,"path":"hexo-your-blog/","link":"","permalink":"https://dc1y.github.io/hexo-your-blog/","excerpt":"你有没有，经历过个人电脑的硬件故障，所有辛苦撰写或整理的资料烟消云散，捧着一块变成砖头的硬盘欲哭无泪？ 你想不想，把你撰写或整理的资料上传到网上，以便可以随时随地进行访问和阅读，并分享给与你有或类似需要的人？ 如果答案是肯定的，那么，你应该搭建一个专属的博客站点。 本文基于 Windows 10 x64 操作系统，主要描述如何利用 Hexo 及 GitHub 和 / 或码云来搭建你的专属博客站点。本文涉及的工具软件及网络服务大致如下：","text":"你有没有，经历过个人电脑的硬件故障，所有辛苦撰写或整理的资料烟消云散，捧着一块变成砖头的硬盘欲哭无泪？ 你想不想，把你撰写或整理的资料上传到网上，以便可以随时随地进行访问和阅读，并分享给与你有或类似需要的人？ 如果答案是肯定的，那么，你应该搭建一个专属的博客站点。 本文基于 Windows 10 x64 操作系统，主要描述如何利用 Hexo 及 GitHub 和 / 或码云来搭建你的专属博客站点。本文涉及的工具软件及网络服务大致如下： Hexo：是一个快速、简洁且高效的静态博客框架，可使用 Markdown 格式来编写博文，能够自动生成静态 html 文件，并一键部署到远程仓库。Hexo 的运行需要 Node.js。 Node.js：是一个基于 Chrome V8 引擎构建的 JavaScript 运行时，让 JavaScript 可以在非浏览器环境下运行。若将 Node.js 视为一个解释器，则 Hexo 就是一个通过这个解释器而运行的应用。 Git：是一个广泛应用的、先进的分布式版本管理工具软件。 GitHub.com：是全球最大的代码托管网站，也是本文博客站点的远程部署位置之一。使用 Git 可以与 GitHub 进行交互，并实现代码仓库的版本管理。 Gitee.com：中文名为码云，是类似于 GitHub 的国内代码托管仓库，可免费建立私有项目，同时也提供了项目管理等更多的功能。 为什么选择 Hexo：目前开源社区存在大量的博客框架，如 WordPress、Jekyll 等，规模不一架构迥异，根据各人知识背景及需求，可能会有不同的偏好和选择。本文选用 Hexo，主要基于轻便、免费及无需后台服务器等方面的考虑。 本文的主要内容有：安装相关软件、建立本地博客站点、部署到远程仓库，以及在多个设备间实现博客站点的同步等。 安装相关软件Hexo 的安装和运行，以及后续博客站点的远程部署和管理，要求在系统中安装好 Git 和 Node.js。 安装 Git 和 Node.js从 Git 和 Node.js 官方网站下载适用本机平台的安装程序，目前 Git 的版本为 2.16.2、Node.js 的版本为 8.9.4。 双击运行刚下载的安装程序，并按屏幕提示完成安装。安装时采用默认选项即可，但要特别注意启用了与环境变量（PATH）相关的选项。 安装完成后，从开始菜单中选择 “Git | Git Bash”（也可使用 Windows 的命令提示符，但推荐使用 GitHub Bash），输入如下命令，若正确显示 Git 和 Node.js 版本，则表明安装成功： $ git versiongit version 2.16.2.windows.1$ node -vv8.9.4 安装 Hexo继续在 Git Bash 中输入如下命令，并耐心等待相关依赖包的下载，当屏幕上显示如下提示且返回提示符 $ 时，即表示 Hexo 已安装完成： $ npm install -g hexo-cli...+ hexo-cli@1.1.0added 103 packages in 25.033s 提示：npm 是随同 Node.js 一起安装的 JavaScript 的包管理器，用于从 NPM 服务器上下载第三方包（例如本文主角 Hexo 等）到本地使用。若国外 NPM 服务器连接不便或速度很慢，可通过如下命令来启用国内的淘宝 NPM 镜像：&gt; $ npm config set registry https://registry.npm.taobao.org&gt; 随后，使用下面的命令来查看刚刚安装的 Hexo 的版本： $ hexo -vhexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64... 至此，相关软件的安装全部完成。这个过程看似复杂，但实际操作起来非常简单：Git 和 Node.js 均有图形安装界面，基本上只需一直 “Next” 即可，而 Hexo 的安装也只是输入 npm install -g hexo-cli 一行命令而已。一切顺利的话，大约几分钟之内就能搞定。 现在，可以开始使用 Hexo 来构建你的专属博客站点了。 建立本地博客站点打开资源管理器，并在你打算存放博客站点的位置（例如 D:\\）中右击并选择 “Git Bash Here”，输入如下命令来让 Hexo 以指定的名称（例如 blog）创建一个文件夹，并将其初始化为 Hexo 博客站点： $ hexo init blogINFO Cloning hexo-starter to D:\\blogCloning into 'D:\\blog'......$ cd blog$ npm install...up to date in 8.258s 返回命令提示符后，表明基本的博客站点已准备就绪。 在资源管理器中查看 blog 文件夹，可发现 Hexo 已自动生成了站点所需的大量内容（如下图）。关于这些文件夹和文件的说明，详见 Hexo 的相关文档。 提示：如果你计划将站点部署到 GitHub 上，则不妨将博客站点文件夹命名为 &lt;username&gt;.github.io 的形式（其中 &lt;username&gt; 是你在 GitHub 上的用户名，下同），以便在本地设备和网络服务间保持一致。 预览本地博客站点启动 Hexo 本地服务器，看看运行中的博客站点是什么样子： $ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开浏览器，在地址栏中输入上面命令中提示的 http://localhost:4000 并回车。一切正常的情况下，就可以看到期待已久的博客站点了（如下图）。Hexo 非常贴心，默认时已经有一篇名为 “Hello World” 的文章，其内容主要是 Hexo 的文档链接，以及几个常用命令的简要说明。 提示：若浏览器无法显示上述地址，可能是 4000 端口已被占用。要解决这个问题，可按 “Ctrl+C” 关闭 Hexo 现有的服务器，然后尝试以其它端口重新启动服务器。 &gt; $ hexo server -p 4001&gt; INFO Start processing&gt; INFO Hexo is running at http://localhost:4001/. Press Ctrl+C to stop.&gt; 配置你的专属信息博客站点已经可以正常运行，但美中不足的是它还不是你专属的博客：网站标题为 “Hexo”，作者为 “John Deo”。要定义你自己的专属信息，可打开站点配置文件（blog/_config.yml），根据下面的 # 注释结合你的实际情况，修改 # Site 的相关选项（必要时添加server并指定自定义的端口），然后保存文件： # Sitetitle: ## 你的站点标题subtitle: ## 你的站点副标题description: ## 你的站点描述（关键字）author: ## 你的名字（作者）language: zh-CN ## 让界面按钮等以中文显示# Server（若 4000 端口确已被占用，可在最后增加这个配置）server: port: 4001 提示：站点配置文件文件采用了 YAML 语言格式，对于内容格式有严格要求，输入时请注意正确缩进，并且在每个 : 之后保留一个空格。 在 Git Bash 中重新启动服务器，再刷新浏览器中的博客站点，可以看到博客站点已真正变成你的专属博客，并且部分界面元素也显示为中文了。 恭喜你！你的专属博客站点已经搭建完毕。现在你可以开始撰写你的博客文章了。 不过，目前的博客站点仍局限在本地，还无法让任何人随时随地通过互联网来访问和阅读。并且，我们还需要未雨绸缪，对博客站点的文章源码及相关配置进行备份，以便万一在本地系统出现故障后，我们仍然能够迅速而又完整地取回博客站点的原始数据。 为此，我们还需要再做一点努力。 博客站点的远程部署实现博客站点的远程部署，显然你需要有一个远程仓库，用来存放已发布的文章，同时也用于备份所有博文的源码及整个博客站点的配置。 创建远程仓库访问 GitHub.com 并注册一个用户，通过邮件激活后登录，然后生成并上传你的 SSH 公钥。 在 GitHub 上创建名为 &lt;username&gt;.github.io 的仓库，注意其中的 &lt;username&gt; 是你在 GitHub 上的用户名，并且用户名之后还应该有 .github.io（不是 .com）。 进入该仓库的 Settings 页面，在 Options | GitHub Pages 部分可看到：GitHub Pages is currently disabled. You must first add content to yourrepository before you can publish a GitHub site。这表明，你必须把本地博客站点部署到这个远程仓库上，才能访问你的 GitHub Pages 主页。 提示：GitHub Pages 是你在 GitHub 上的用户 / 组织或项目的主页，每个 GitHub 用户 / 组织只能有一个用户 / 组织主页，但可以有数量不限的项目主页。GitHub Pages 基于相应的 GitHub 用户或仓库，只需把编辑后的内容推送到仓库，主页的内容即可自动更新。 部署前的准备在使用 Hexo 把博客站点部署到 GitHub 之前，还必须先安装部署工具，并对要部署的内容及目标位置进行一些配置。 安装部署工具对应于 Git 的 Hexo 部署工具是 “hexo-deployer-git”。在 blog 文件夹中打开 Git Bash，并输入如下命令来安装这个部署工具（从输出结果中可以看到，当前 hexo-deployer-git 的版本为 0.31）： $ npm install hexo-deployer-git --save...+ hexo-deployer-git@0.3.1added 31 packages in 16.036s 配置部署选项再次打开此前修改站点专属信息的配置文件（blog/_config.yml），找到 deploy 部分，并输入如下配置： deploy: - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: src extend_dirs: / ignore_hidden: false ignore_pattern: public: . 采用上述配置，Hexo 将在执行一键部署时，一次性把已发表的博客文章推送到远程仓库的 master 分支，同时把文章源码及站点相关设置推送到 src 分支： 提示：关于各部署选项的详细说明，请参阅 hexo-deployer-git 在 GitHub 上的说明。 执行部署与备份现在，终于可以进行一键部署了。在 blog 文件夹中打开 “Git Bash”，并运行如下命令。在一大堆输出的最后，出现了 INFO Deploy done: git 并返回提示符 $，表示部署完毕： $ hexo deploy...INFO Deploy done: git 博客站点的远程部署已经完成，赶快拿起你的手机（正在使用的电脑也可以），打开浏览器，输入 https://&lt;username&gt;.github.io 并进入。不出意料的话，你应该可以看到此前在本地服务器上看到的 “Hello World” 页面。 在 GitHub 上打开你的 &lt;username&gt;.github.io 仓库。进入 master 分支，可看到已发布的博客文章；进入 src 分支，可看到存放博文源码的 source 文件夹，刚刚修改过的 _config.yml，以及 .gitignore 等等与站点配置相关的文件夹和文件等。由此，你可以确认，本地站点的所有有效内容，都已推送并备份至远程仓库。 从此，你只需在每次新建或修改文章、或者是改变站点的配置之后，简单地执行一次部署，就可确信就算末日来临，你的专属博客的一切都不会丢失。甚至，如果你比我还懒的话，部署时可以输入简化的 hexo d -g 命令。 把博客部署到码云什么？你觉得 GitHub 速度太慢，并且有时候可能被墙导致无法访问？或许，你应该试试国内的代码托管网站 码云。 码云也提供了类似的 Pages 服务，托管你的博客的套路与也 GitHub 差不多：同样需要注册激活登录，上传 SSH 公钥，然后创建 &lt;username&gt; 项目（注意：与 GitHub 不同的是，不需要也不可以有 gitee.io 后缀）；进入项目页面选择 “服务 | Pages”, 再选择 “master” 分支并单击 “启动服务”。这样，码云的远程仓库就准备好了。 接着，把站点配置文件 deploy 部分的 repo 修改为包含 github 和 gitee 两个子节点，并在子节点的定义中指定远程仓库的地址及目标分支。这样，你就可以一次性地把你的博客站点同时部署到 GitHub 和码云上了。 deploy: - type: git repo: github: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git,master gitee: git@gitee.com:&lt;username&gt;/&lt;username&gt;.git,master - type: git repo: github: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git,src gitee: git@gitee.com:&lt;username&gt;/&lt;username&gt;.git,src extend_dirs: / ignore_hidden: false ignore_pattern: public: . 警告：repo 子节点的仓库地址和分支之间只有一个逗号（,），不能有空格。否则将出现 fatal: remote part of refspec is not a valid name in HEAD: master 错误，并且部署中断。 在浏览器中访问 &lt;username&gt;.gitee.io（没错，这里需要 gitee.io），就可以访问你部署在码云上的博客了。 多设备同步把博客站点部署到远程仓库后，你发表的博客文章已经可以随处阅读了。但是，你还想在公司在家里在路上在洗手间…… 在浴缸里撰写并发表博客，又该怎么办？ 这好办！ 克隆远程仓库找另一台电脑，没有的话，在本机上找一个临时文件夹也行。在希望存放本地博客站点的位置打开 “Git Bash”，然后输入如下命令来把远程仓库克隆到 blog 目录中： $ git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git blogCloning into '&lt;username&gt;.github.io'...... done. 提示：若要从码云上克隆仓库，则使用 git clone git@gitee.com:&lt;username&gt;/&lt;username&gt;.git blog 命令。 在资源管理器中打开克隆到的 blog 文件夹，并查看其内容： 怎么回事？这个克隆仓库中，居然只有已发表的博客文章。说好的源码呢？精心挑选的主题呢？复杂难解的站点配置都到哪去了？别担心，它们就在仓库里。你要做的，只是进入本地的克隆仓库，并切换到 src 分支： $ cd blog$ git checkout srcSwitched to branch 'src'Your branch is up to date with 'origin/src'. 再次查看 blog 文件夹的内容，谢天谢地，终于都回来了： 重新初始化本地站点不过，先别高兴得太早。克隆下来的文件夹中，并不包含运行 Hexo 所需的 node_modules 文件夹及 db.json 文件。为此，可退回在 blog 的上级目录，并按前面 “建立本地博客站点” 所述的方式，初始化一个临时的博客站点： cd ..$ hexo init temp_hexoINFO Cloning hexo-starter to D:\\temp\\temphexo...$ cd temp_hexo$ npm install 然后，在资源管理器中，拷贝 temp_hexo 文件夹中的全部文件，并粘贴到 blog 文件夹中（注意：必须先在 blog 切换到 src 分支）。当出现 “同名文件” 提示时，切记选择 “跳过这些文件”，以便保留来自远程仓库的站点最新内容及配置。 为稳妥起见，可参照前面 “测试本地博客站点” 的方式，启动 Hexo 服务器并在浏览器中检查博客的内容是否正确。再打开 _config.yml 并查看自定义的配置（例如前面的部署配置）是否仍然存在，而不是被覆盖为刚刚初始化的站点设置。 一切检查无误之后，你就可以在新设备上撰写和部署你的博客了。 尾声折腾了这么久，你终于可以、也应该写一篇博客了吧？如果你一时半会儿想不出来要写什么，那么这个折腾过程本身就是一个不错的主题。如果你还是嫌麻烦，至少也应该写一篇最为短小精悍的博文，并在其中只包含一个指向本文的链接吧。 至于如何流畅快速地创建、撰写和管理博文，请参阅 《VS Code，打造沉浸式的Hexo写作环境》，或者是看看官方文档的 “写作” 部分。 现在，如果你又修改了站点的内容，无论是修改了站点配置，还是撰写了新的博文，你都应该马上执行一次部署，以免意外丢失你的工作。然后，你就可以安心休息了……","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://dc1y.github.io/categories/实用工具/"},{"name":"Hexo","slug":"实用工具/Hexo","permalink":"https://dc1y.github.io/categories/实用工具/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dc1y.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://dc1y.github.io/tags/GitHub/"},{"name":"码云","slug":"码云","permalink":"https://dc1y.github.io/tags/码云/"}]}]}